{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { get, post, put, remove } from './lib/fetch';\nimport { COOKIE_OPTIONS } from './lib/constants';\nimport { setCookies, getCookieString } from './lib/cookies';\nimport { expiresAt, resolveFetch } from './lib/helpers';\nexport default class GoTrueApi {\n  constructor(_ref) {\n    let {\n      url = '',\n      headers = {},\n      cookieOptions,\n      fetch\n    } = _ref;\n    this.url = url;\n    this.headers = headers;\n    this.cookieOptions = Object.assign(Object.assign({}, COOKIE_OPTIONS), cookieOptions);\n    this.fetch = resolveFetch(fetch);\n  }\n  /**\n   * Create a temporary object with all configured headers and\n   * adds the Authorization token to be used on request methods\n   * @param jwt A valid, logged-in JWT.\n   */\n  _createRequestHeaders(jwt) {\n    const headers = Object.assign({}, this.headers);\n    headers['Authorization'] = `Bearer ${jwt}`;\n    return headers;\n  }\n  cookieName() {\n    var _a;\n    return (_a = this.cookieOptions.name) !== null && _a !== void 0 ? _a : '';\n  }\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n  getUrlForProvider(provider, options) {\n    const urlParams = [`provider=${encodeURIComponent(provider)}`];\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n    }\n    if (options === null || options === void 0 ? void 0 : options.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n    }\n    if (options === null || options === void 0 ? void 0 : options.queryParams) {\n      const query = new URLSearchParams(options.queryParams);\n      urlParams.push(`${query}`);\n    }\n    return `${this.url}/authorize?${urlParams.join('&')}`;\n  }\n  /**\n   * Creates a new user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   *\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n  signUpWithEmail(email, password) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n        if (options.redirectTo) {\n          queryString = '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n        const data = yield post(this.fetch, `${this.url}/signup${queryString}`, {\n          email,\n          password,\n          data: options.data,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Logs in an existing user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  signInWithEmail(email, password) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '?grant_type=password';\n        if (options.redirectTo) {\n          queryString += '&redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n        const data = yield post(this.fetch, `${this.url}/token${queryString}`, {\n          email,\n          password,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Signs up a new user using their phone number and a password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   * @param data Optional user metadata.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  signUpWithPhone(phone, password) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/signup`, {\n          phone,\n          password,\n          data: options.data,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Logs in an existing user using their phone number and password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  signInWithPhone(phone, password) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const queryString = '?grant_type=password';\n        const data = yield post(this.fetch, `${this.url}/token${queryString}`, {\n          phone,\n          password,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Logs in an OpenID Connect user using their id_token.\n   * @param id_token The IDToken of the user.\n   * @param nonce The nonce of the user. The nonce is a random value generated by the developer (= yourself) before the initial grant is started. You should check the OpenID Connect specification for details. https://openid.net/developers/specs/\n   * @param provider The provider of the user.\n   * @param client_id The clientID of the user.\n   * @param issuer The issuer of the user.\n   */\n  signInWithOpenIDConnect(_ref2) {\n    let {\n      id_token,\n      nonce,\n      client_id,\n      issuer,\n      provider\n    } = _ref2;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const queryString = '?grant_type=id_token';\n        const data = yield post(this.fetch, `${this.url}/token${queryString}`, {\n          id_token,\n          nonce,\n          client_id,\n          issuer,\n          provider\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends a magic login link to an email address.\n   * @param email The email address of the user.\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  sendMagicLinkEmail(email) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n        if (options.redirectTo) {\n          queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n        const shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n        const data = yield post(this.fetch, `${this.url}/otp${queryString}`, {\n          email,\n          create_user: shouldCreateUser,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends a mobile OTP via SMS. Will register the account if it doesn't already exist\n   * @param phone The user's phone number WITH international prefix\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  sendMobileOTP(phone) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/otp`, {\n          phone,\n          create_user: shouldCreateUser,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Removes a logged-in session.\n   * @param jwt A valid, logged-in JWT.\n   */\n  signOut(jwt) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield post(this.fetch, `${this.url}/logout`, {}, {\n          headers: this._createRequestHeaders(jwt),\n          noResolveJson: true\n        });\n        return {\n          error: null\n        };\n      } catch (e) {\n        return {\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * @deprecated Use `verifyOTP` instead!\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  verifyMobileOTP(phone, token) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/verify`, {\n          phone,\n          token,\n          type: 'sms',\n          redirect_to: options.redirectTo\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Send User supplied Email / Mobile OTP to be verified\n   * @param email The user's email address\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param type verification type that the otp is generated for\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  verifyOTP(_ref3) {\n    let {\n      email,\n      phone,\n      token,\n      type = 'sms'\n    } = _ref3;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        const data = yield post(this.fetch, `${this.url}/verify`, {\n          email,\n          phone,\n          token,\n          type,\n          redirect_to: options.redirectTo\n        }, {\n          headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends an invite link to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata\n   */\n  inviteUserByEmail(email) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n        if (options.redirectTo) {\n          queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n        const data = yield post(this.fetch, `${this.url}/invite${queryString}`, {\n          email,\n          data: options.data\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Sends a reset request to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  resetPasswordForEmail(email) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const headers = Object.assign({}, this.headers);\n        let queryString = '';\n        if (options.redirectTo) {\n          queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n        }\n        const data = yield post(this.fetch, `${this.url}/recover${queryString}`, {\n          email,\n          gotrue_meta_security: {\n            captcha_token: options.captchaToken\n          }\n        }, {\n          headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n  refreshAccessToken(refreshToken) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/token?grant_type=refresh_token`, {\n          refresh_token: refreshToken\n        }, {\n          headers: this.headers\n        });\n        const session = Object.assign({}, data);\n        if (session.expires_in) session.expires_at = expiresAt(data.expires_in);\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Set/delete the auth cookie based on the AuthChangeEvent.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   * @param req The request object.\n   * @param res The response object.\n   */\n  setAuthCookie(req, res) {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST');\n      res.status(405).end('Method Not Allowed');\n    }\n    const {\n      event,\n      session\n    } = req.body;\n    if (!event) throw new Error('Auth event missing!');\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!');\n      setCookies(req, res, [{\n        key: 'access-token',\n        value: session.access_token\n      }, {\n        key: 'refresh-token',\n        value: session.refresh_token\n      }].map(token => {\n        var _a;\n        return {\n          name: `${this.cookieName()}-${token.key}`,\n          value: token.value,\n          domain: this.cookieOptions.domain,\n          maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n          path: this.cookieOptions.path,\n          sameSite: this.cookieOptions.sameSite\n        };\n      }));\n    }\n    if (event === 'SIGNED_OUT') {\n      setCookies(req, res, ['access-token', 'refresh-token'].map(key => ({\n        name: `${this.cookieName()}-${key}`,\n        value: '',\n        maxAge: -1\n      })));\n    }\n    res.status(200).json({});\n  }\n  /**\n   * Deletes the Auth Cookies and redirects to the\n   * @param req The request object.\n   * @param res The response object.\n   * @param options Optionally specify a `redirectTo` URL in the options.\n   */\n  deleteAuthCookie(req, res, _ref4) {\n    let {\n      redirectTo = '/'\n    } = _ref4;\n    setCookies(req, res, ['access-token', 'refresh-token'].map(key => ({\n      name: `${this.cookieName()}-${key}`,\n      value: '',\n      maxAge: -1\n    })));\n    return res.redirect(307, redirectTo);\n  }\n  /**\n   * Helper method to generate the Auth Cookie string for you in case you can't use `setAuthCookie`.\n   * @param req The request object.\n   * @param res The response object.\n   * @returns The Cookie string that needs to be set as the value for the `Set-Cookie` header.\n   */\n  getAuthCookieString(req, res) {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST');\n      res.status(405).end('Method Not Allowed');\n    }\n    const {\n      event,\n      session\n    } = req.body;\n    if (!event) throw new Error('Auth event missing!');\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!');\n      return getCookieString(req, res, [{\n        key: 'access-token',\n        value: session.access_token\n      }, {\n        key: 'refresh-token',\n        value: session.refresh_token\n      }].map(token => {\n        var _a;\n        return {\n          name: `${this.cookieName()}-${token.key}`,\n          value: token.value,\n          domain: this.cookieOptions.domain,\n          maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n          path: this.cookieOptions.path,\n          sameSite: this.cookieOptions.sameSite\n        };\n      }));\n    }\n    if (event === 'SIGNED_OUT') {\n      return getCookieString(req, res, ['access-token', 'refresh-token'].map(key => ({\n        name: `${this.cookieName()}-${key}`,\n        value: '',\n        maxAge: -1\n      })));\n    }\n    return res.getHeader('Set-Cookie');\n  }\n  /**\n   * Generates links to be sent via email or other.\n   * @param type The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   * @param email The user's email.\n   * @param password User password. For signup only.\n   * @param data Optional user metadata. For signup only.\n   * @param redirectTo The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   */\n  generateLink(type, email) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/admin/generate_link`, {\n          type,\n          email,\n          password: options.password,\n          data: options.data,\n          redirect_to: options.redirectTo\n        }, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  // User Admin API\n  /**\n   * Creates a new user.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param attributes The data you want to create the user with.\n   */\n  createUser(attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/admin/users`, attributes, {\n          headers: this.headers\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Get a list of users.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  listUsers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/admin/users`, {\n          headers: this.headers\n        });\n        return {\n          data: data.users,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Get user by id.\n   *\n   * @param uid The user's unique identifier\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  getUserById(uid) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/admin/users/${uid}`, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Get user by reading the cookie from the request.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   */\n  getUserByCookie(req, res) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!req.cookies) {\n          throw new Error('Not able to parse cookies! When using Express make sure the cookie-parser middleware is in use!');\n        }\n        const access_token = req.cookies[`${this.cookieName()}-access-token`];\n        const refresh_token = req.cookies[`${this.cookieName()}-refresh-token`];\n        if (!access_token) {\n          throw new Error('No cookie found!');\n        }\n        const {\n          user,\n          error: getUserError\n        } = yield this.getUser(access_token);\n        if (getUserError) {\n          if (!refresh_token) throw new Error('No refresh_token cookie found!');\n          if (!res) throw new Error('You need to pass the res object to automatically refresh the session!');\n          const {\n            data,\n            error\n          } = yield this.refreshAccessToken(refresh_token);\n          if (error) {\n            throw error;\n          } else if (data) {\n            setCookies(req, res, [{\n              key: 'access-token',\n              value: data.access_token\n            }, {\n              key: 'refresh-token',\n              value: data.refresh_token\n            }].map(token => {\n              var _a;\n              return {\n                name: `${this.cookieName()}-${token.key}`,\n                value: token.value,\n                domain: this.cookieOptions.domain,\n                maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n                path: this.cookieOptions.path,\n                sameSite: this.cookieOptions.sameSite\n              };\n            }));\n            return {\n              token: data.access_token,\n              user: data.user,\n              data: data.user,\n              error: null\n            };\n          }\n        }\n        return {\n          token: access_token,\n          user: user,\n          data: user,\n          error: null\n        };\n      } catch (e) {\n        return {\n          token: null,\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Updates the user data.\n   *\n   * @param attributes The data you want to update.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  updateUserById(uid, attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this; //\n        const data = yield put(this.fetch, `${this.url}/admin/users/${uid}`, attributes, {\n          headers: this.headers\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Delete a user. Requires a `service_role` key.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param uid The user uid you want to remove.\n   */\n  deleteUser(uid) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield remove(this.fetch, `${this.url}/admin/users/${uid}`, {}, {\n          headers: this.headers\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Gets the current user details.\n   *\n   * This method is called by the GoTrueClient `update` where\n   * the jwt is set to this.currentSession.access_token\n   * and therefore, acts like getting the currently authenticated user\n   *\n   * @param jwt A valid, logged-in JWT. Typically, the access_token for the currentSession\n   */\n  getUser(jwt) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield get(this.fetch, `${this.url}/user`, {\n          headers: this._createRequestHeaders(jwt)\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Updates the user data.\n   * @param jwt A valid, logged-in JWT.\n   * @param attributes The data you want to update.\n   */\n  updateUser(jwt, attributes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield put(this.fetch, `${this.url}/user`, attributes, {\n          headers: this._createRequestHeaders(jwt)\n        });\n        return {\n          user: data,\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n}","map":{"version":3,"names":["get","post","put","remove","COOKIE_OPTIONS","setCookies","getCookieString","expiresAt","resolveFetch","GoTrueApi","constructor","_ref","url","headers","cookieOptions","fetch","Object","assign","_createRequestHeaders","jwt","cookieName","_a","name","getUrlForProvider","provider","options","urlParams","encodeURIComponent","redirectTo","push","scopes","queryParams","query","URLSearchParams","join","signUpWithEmail","email","password","arguments","length","undefined","queryString","data","gotrue_meta_security","captcha_token","captchaToken","session","expires_in","expires_at","error","e","signInWithEmail","signUpWithPhone","phone","signInWithPhone","signInWithOpenIDConnect","_ref2","id_token","nonce","client_id","issuer","sendMagicLinkEmail","shouldCreateUser","create_user","sendMobileOTP","signOut","noResolveJson","verifyMobileOTP","token","type","redirect_to","verifyOTP","_ref3","inviteUserByEmail","resetPasswordForEmail","refreshAccessToken","refreshToken","refresh_token","setAuthCookie","req","res","method","setHeader","status","end","event","body","Error","key","value","access_token","map","domain","maxAge","lifetime","path","sameSite","json","deleteAuthCookie","_ref4","redirect","getAuthCookieString","getHeader","generateLink","createUser","attributes","user","listUsers","users","getUserById","uid","getUserByCookie","cookies","getUserError","getUser","updateUserById","deleteUser","updateUser"],"sources":["/workspaces/R-MPAGE/rick-and-morty-rating/node_modules/@supabase/gotrue-js/src/GoTrueApi.ts"],"sourcesContent":["import { Fetch, get, post, put, remove } from './lib/fetch'\nimport {\n  Session,\n  Provider,\n  AdminUserAttributes,\n  UserAttributes,\n  CookieOptions,\n  User,\n  OpenIDConnectCredentials,\n  VerifyOTPParams,\n} from './lib/types'\nimport { COOKIE_OPTIONS } from './lib/constants'\nimport { setCookies, getCookieString } from './lib/cookies'\nimport { expiresAt, resolveFetch } from './lib/helpers'\n\nimport type { ApiError } from './lib/types'\nexport default class GoTrueApi {\n  protected url: string\n  protected headers: {\n    [key: string]: string\n  }\n  protected cookieOptions: CookieOptions\n  protected fetch: Fetch\n\n  constructor({\n    url = '',\n    headers = {},\n    cookieOptions,\n    fetch,\n  }: {\n    url: string\n    headers?: {\n      [key: string]: string\n    }\n    cookieOptions?: CookieOptions\n    fetch?: Fetch\n  }) {\n    this.url = url\n    this.headers = headers\n    this.cookieOptions = { ...COOKIE_OPTIONS, ...cookieOptions }\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /**\n   * Create a temporary object with all configured headers and\n   * adds the Authorization token to be used on request methods\n   * @param jwt A valid, logged-in JWT.\n   */\n  private _createRequestHeaders(jwt: string) {\n    const headers = { ...this.headers }\n    headers['Authorization'] = `Bearer ${jwt}`\n    return headers\n  }\n\n  private cookieName() {\n    return this.cookieOptions.name ?? ''\n  }\n\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n  getUrlForProvider(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n      queryParams?: { [key: string]: string }\n    }\n  ) {\n    const urlParams: string[] = [`provider=${encodeURIComponent(provider)}`]\n    if (options?.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`)\n    }\n    if (options?.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`)\n    }\n    if (options?.queryParams) {\n      const query = new URLSearchParams(options.queryParams)\n      urlParams.push(`${query}`)\n    }\n    return `${this.url}/authorize?${urlParams.join('&')}`\n  }\n\n  /**\n   * Creates a new user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   *\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n  async signUpWithEmail(\n    email: string,\n    password: string,\n    options: {\n      redirectTo?: string\n      data?: object\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString = '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/signup${queryString}`,\n        {\n          email,\n          password,\n          data: options.data,\n          gotrue_meta_security: { captcha_token: options.captchaToken },\n        },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Logs in an existing user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  async signInWithEmail(\n    email: string,\n    password: string,\n    options: {\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = '?grant_type=password'\n      if (options.redirectTo) {\n        queryString += '&redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/token${queryString}`,\n        { email, password, gotrue_meta_security: { captcha_token: options.captchaToken } },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Signs up a new user using their phone number and a password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   * @param data Optional user metadata.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  async signUpWithPhone(\n    phone: string,\n    password: string,\n    options: {\n      data?: object\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const data = await post(\n        this.fetch,\n        `${this.url}/signup`,\n        {\n          phone,\n          password,\n          data: options.data,\n          gotrue_meta_security: { captcha_token: options.captchaToken },\n        },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Logs in an existing user using their phone number and password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  async signInWithPhone(\n    phone: string,\n    password: string,\n    options: {\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const queryString = '?grant_type=password'\n      const data = await post(\n        this.fetch,\n        `${this.url}/token${queryString}`,\n        { phone, password, gotrue_meta_security: { captcha_token: options.captchaToken } },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Logs in an OpenID Connect user using their id_token.\n   * @param id_token The IDToken of the user.\n   * @param nonce The nonce of the user. The nonce is a random value generated by the developer (= yourself) before the initial grant is started. You should check the OpenID Connect specification for details. https://openid.net/developers/specs/\n   * @param provider The provider of the user.\n   * @param client_id The clientID of the user.\n   * @param issuer The issuer of the user.\n   */\n  async signInWithOpenIDConnect({\n    id_token,\n    nonce,\n    client_id,\n    issuer,\n    provider,\n  }: OpenIDConnectCredentials): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const queryString = '?grant_type=id_token'\n      const data = await post(\n        this.fetch,\n        `${this.url}/token${queryString}`,\n        { id_token, nonce, client_id, issuer, provider },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends a magic login link to an email address.\n   * @param email The email address of the user.\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  async sendMagicLinkEmail(\n    email: string,\n    options: {\n      shouldCreateUser?: boolean\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: {} | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n\n      const shouldCreateUser = options.shouldCreateUser ?? true\n      const data = await post(\n        this.fetch,\n        `${this.url}/otp${queryString}`,\n        {\n          email,\n          create_user: shouldCreateUser,\n          gotrue_meta_security: { captcha_token: options.captchaToken },\n        },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends a mobile OTP via SMS. Will register the account if it doesn't already exist\n   * @param phone The user's phone number WITH international prefix\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  async sendMobileOTP(\n    phone: string,\n    options: {\n      shouldCreateUser?: boolean\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: {} | null; error: ApiError | null }> {\n    try {\n      const shouldCreateUser = options.shouldCreateUser ?? true\n      const headers = { ...this.headers }\n      const data = await post(\n        this.fetch,\n        `${this.url}/otp`,\n        {\n          phone,\n          create_user: shouldCreateUser,\n          gotrue_meta_security: { captcha_token: options.captchaToken },\n        },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Removes a logged-in session.\n   * @param jwt A valid, logged-in JWT.\n   */\n  async signOut(jwt: string): Promise<{ error: ApiError | null }> {\n    try {\n      await post(\n        this.fetch,\n        `${this.url}/logout`,\n        {},\n        { headers: this._createRequestHeaders(jwt), noResolveJson: true }\n      )\n      return { error: null }\n    } catch (e) {\n      return { error: e as ApiError }\n    }\n  }\n\n  /**\n   * @deprecated Use `verifyOTP` instead!\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async verifyMobileOTP(\n    phone: string,\n    token: string,\n    options: {\n      redirectTo?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const data = await post(\n        this.fetch,\n        `${this.url}/verify`,\n        { phone, token, type: 'sms', redirect_to: options.redirectTo },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Send User supplied Email / Mobile OTP to be verified\n   * @param email The user's email address\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param type verification type that the otp is generated for\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async verifyOTP(\n    { email, phone, token, type = 'sms' }: VerifyOTPParams,\n    options: {\n      redirectTo?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const data = await post(\n        this.fetch,\n        `${this.url}/verify`,\n        { email, phone, token, type, redirect_to: options.redirectTo },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends an invite link to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata\n   */\n  async inviteUserByEmail(\n    email: string,\n    options: {\n      redirectTo?: string\n      data?: object\n    } = {}\n  ): Promise<{ data: User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/invite${queryString}`,\n        { email, data: options.data },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends a reset request to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  async resetPasswordForEmail(\n    email: string,\n    options: {\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: {} | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/recover${queryString}`,\n        { email, gotrue_meta_security: { captcha_token: options.captchaToken } },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n  async refreshAccessToken(\n    refreshToken: string\n  ): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      const data: any = await post(\n        this.fetch,\n        `${this.url}/token?grant_type=refresh_token`,\n        { refresh_token: refreshToken },\n        { headers: this.headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Set/delete the auth cookie based on the AuthChangeEvent.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   * @param req The request object.\n   * @param res The response object.\n   */\n  setAuthCookie(req: any, res: any) {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST')\n      res.status(405).end('Method Not Allowed')\n    }\n    const { event, session } = req.body\n\n    if (!event) throw new Error('Auth event missing!')\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!')\n      setCookies(\n        req,\n        res,\n        [\n          { key: 'access-token', value: session.access_token },\n          { key: 'refresh-token', value: session.refresh_token },\n        ].map((token) => ({\n          name: `${this.cookieName()}-${token.key}`,\n          value: token.value,\n          domain: this.cookieOptions.domain,\n          maxAge: this.cookieOptions.lifetime ?? 0,\n          path: this.cookieOptions.path,\n          sameSite: this.cookieOptions.sameSite,\n        }))\n      )\n    }\n    if (event === 'SIGNED_OUT') {\n      setCookies(\n        req,\n        res,\n        ['access-token', 'refresh-token'].map((key) => ({\n          name: `${this.cookieName()}-${key}`,\n          value: '',\n          maxAge: -1,\n        }))\n      )\n    }\n    res.status(200).json({})\n  }\n\n  /**\n   * Deletes the Auth Cookies and redirects to the\n   * @param req The request object.\n   * @param res The response object.\n   * @param options Optionally specify a `redirectTo` URL in the options.\n   */\n  deleteAuthCookie(req: any, res: any, { redirectTo = '/' }: { redirectTo?: string }) {\n    setCookies(\n      req,\n      res,\n      ['access-token', 'refresh-token'].map((key) => ({\n        name: `${this.cookieName()}-${key}`,\n        value: '',\n        maxAge: -1,\n      }))\n    )\n    return res.redirect(307, redirectTo)\n  }\n\n  /**\n   * Helper method to generate the Auth Cookie string for you in case you can't use `setAuthCookie`.\n   * @param req The request object.\n   * @param res The response object.\n   * @returns The Cookie string that needs to be set as the value for the `Set-Cookie` header.\n   */\n  getAuthCookieString(req: any, res: any): string[] {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST')\n      res.status(405).end('Method Not Allowed')\n    }\n    const { event, session } = req.body\n\n    if (!event) throw new Error('Auth event missing!')\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!')\n      return getCookieString(\n        req,\n        res,\n        [\n          { key: 'access-token', value: session.access_token },\n          { key: 'refresh-token', value: session.refresh_token },\n        ].map((token) => ({\n          name: `${this.cookieName()}-${token.key}`,\n          value: token.value,\n          domain: this.cookieOptions.domain,\n          maxAge: this.cookieOptions.lifetime ?? 0,\n          path: this.cookieOptions.path,\n          sameSite: this.cookieOptions.sameSite,\n        }))\n      )\n    }\n    if (event === 'SIGNED_OUT') {\n      return getCookieString(\n        req,\n        res,\n        ['access-token', 'refresh-token'].map((key) => ({\n          name: `${this.cookieName()}-${key}`,\n          value: '',\n          maxAge: -1,\n        }))\n      )\n    }\n    return res.getHeader('Set-Cookie')\n  }\n\n  /**\n   * Generates links to be sent via email or other.\n   * @param type The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   * @param email The user's email.\n   * @param password User password. For signup only.\n   * @param data Optional user metadata. For signup only.\n   * @param redirectTo The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   */\n  async generateLink(\n    type:\n      | 'signup'\n      | 'magiclink'\n      | 'recovery'\n      | 'invite'\n      | 'email_change_current'\n      | 'email_change_new',\n    email: string,\n    options: {\n      password?: string\n      data?: object\n      redirectTo?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const data: any = await post(\n        this.fetch,\n        `${this.url}/admin/generate_link`,\n        {\n          type,\n          email,\n          password: options.password,\n          data: options.data,\n          redirect_to: options.redirectTo,\n        },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  // User Admin API\n\n  /**\n   * Creates a new user.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param attributes The data you want to create the user with.\n   */\n  async createUser(\n    attributes: AdminUserAttributes\n  ): Promise<\n    { user: null; data: null; error: ApiError } | { user: User; data: User; error: null }\n  > {\n    try {\n      const data: any = await post(this.fetch, `${this.url}/admin/users`, attributes, {\n        headers: this.headers,\n      })\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Get a list of users.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async listUsers(): Promise<{ data: null; error: ApiError } | { data: User[]; error: null }> {\n    try {\n      const data: any = await get(this.fetch, `${this.url}/admin/users`, {\n        headers: this.headers,\n      })\n      return { data: data.users, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Get user by id.\n   *\n   * @param uid The user's unique identifier\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async getUserById(\n    uid: string\n  ): Promise<{ data: null; error: ApiError } | { data: User; error: null }> {\n    try {\n      const data: any = await get(this.fetch, `${this.url}/admin/users/${uid}`, {\n        headers: this.headers,\n      })\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Get user by reading the cookie from the request.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   */\n  async getUserByCookie(\n    req: any,\n    res?: any\n  ): Promise<{\n    token: string | null\n    user: User | null\n    data: User | null\n    error: ApiError | null\n  }> {\n    try {\n      if (!req.cookies) {\n        throw new Error(\n          'Not able to parse cookies! When using Express make sure the cookie-parser middleware is in use!'\n        )\n      }\n\n      const access_token = req.cookies[`${this.cookieName()}-access-token`]\n      const refresh_token = req.cookies[`${this.cookieName()}-refresh-token`]\n\n      if (!access_token) {\n        throw new Error('No cookie found!')\n      }\n\n      const { user, error: getUserError } = await this.getUser(access_token)\n      if (getUserError) {\n        if (!refresh_token) throw new Error('No refresh_token cookie found!')\n        if (!res)\n          throw new Error('You need to pass the res object to automatically refresh the session!')\n        const { data, error } = await this.refreshAccessToken(refresh_token)\n        if (error) {\n          throw error\n        } else if (data) {\n          setCookies(\n            req,\n            res,\n            [\n              { key: 'access-token', value: data.access_token },\n              { key: 'refresh-token', value: data.refresh_token! },\n            ].map((token) => ({\n              name: `${this.cookieName()}-${token.key}`,\n              value: token.value,\n              domain: this.cookieOptions.domain,\n              maxAge: this.cookieOptions.lifetime ?? 0,\n              path: this.cookieOptions.path,\n              sameSite: this.cookieOptions.sameSite,\n            }))\n          )\n          return { token: data.access_token, user: data.user, data: data.user, error: null }\n        }\n      }\n      return { token: access_token, user: user, data: user, error: null }\n    } catch (e) {\n      return { token: null, user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Updates the user data.\n   *\n   * @param attributes The data you want to update.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async updateUserById(\n    uid: string,\n    attributes: AdminUserAttributes\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\n    try {\n      this //\n      const data: any = await put(this.fetch, `${this.url}/admin/users/${uid}`, attributes, {\n        headers: this.headers,\n      })\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Delete a user. Requires a `service_role` key.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param uid The user uid you want to remove.\n   */\n  async deleteUser(\n    uid: string\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\n    try {\n      const data: any = await remove(\n        this.fetch,\n        `${this.url}/admin/users/${uid}`,\n        {},\n        {\n          headers: this.headers,\n        }\n      )\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Gets the current user details.\n   *\n   * This method is called by the GoTrueClient `update` where\n   * the jwt is set to this.currentSession.access_token\n   * and therefore, acts like getting the currently authenticated user\n   *\n   * @param jwt A valid, logged-in JWT. Typically, the access_token for the currentSession\n   */\n  async getUser(\n    jwt: string\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\n    try {\n      const data: any = await get(this.fetch, `${this.url}/user`, {\n        headers: this._createRequestHeaders(jwt),\n      })\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Updates the user data.\n   * @param jwt A valid, logged-in JWT.\n   * @param attributes The data you want to update.\n   */\n  async updateUser(\n    jwt: string,\n    attributes: UserAttributes\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\n    try {\n      const data: any = await put(this.fetch, `${this.url}/user`, attributes, {\n        headers: this._createRequestHeaders(jwt),\n      })\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}