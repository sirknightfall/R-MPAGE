{"ast":null,"code":"import { Transformers } from '@supabase/realtime-js';\nexport class SupabaseRealtimeClient {\n  constructor(socket, headers, schema, tableName) {\n    const chanParams = {};\n    const topic = tableName === '*' ? `realtime:${schema}` : `realtime:${schema}:${tableName}`;\n    const userToken = headers['Authorization'].split(' ')[1];\n    if (userToken) {\n      chanParams['user_token'] = userToken;\n    }\n    this.subscription = socket.channel(topic, chanParams);\n  }\n  getPayloadRecords(payload) {\n    const records = {\n      new: {},\n      old: {}\n    };\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n      records.new = Transformers.convertChangeData(payload.columns, payload.record);\n    }\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n      records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\n    }\n    return records;\n  }\n  /**\n   * The event you want to listen to.\n   *\n   * @param event The event\n   * @param callback A callback function that is called whenever the event occurs.\n   */\n  on(event, callback) {\n    this.subscription.on(event, payload => {\n      let enrichedPayload = {\n        schema: payload.schema,\n        table: payload.table,\n        commit_timestamp: payload.commit_timestamp,\n        eventType: payload.type,\n        new: {},\n        old: {},\n        errors: payload.errors\n      };\n      enrichedPayload = Object.assign(Object.assign({}, enrichedPayload), this.getPayloadRecords(payload));\n      callback(enrichedPayload);\n    });\n    return this;\n  }\n  /**\n   * Enables the subscription.\n   */\n  subscribe() {\n    let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};\n    this.subscription.onError(e => callback('SUBSCRIPTION_ERROR', e));\n    this.subscription.onClose(() => callback('CLOSED'));\n    this.subscription.subscribe().receive('ok', () => callback('SUBSCRIBED')).receive('error', e => callback('SUBSCRIPTION_ERROR', e)).receive('timeout', () => callback('RETRYING_AFTER_TIMEOUT'));\n    return this.subscription;\n  }\n}","map":{"version":3,"names":["Transformers","SupabaseRealtimeClient","constructor","socket","headers","schema","tableName","chanParams","topic","userToken","split","subscription","channel","getPayloadRecords","payload","records","new","old","type","convertChangeData","columns","record","old_record","on","event","callback","enrichedPayload","table","commit_timestamp","eventType","errors","Object","assign","subscribe","arguments","length","undefined","onError","e","onClose","receive"],"sources":["/workspaces/R-MPAGE/rick-and-morty-rating/node_modules/@supabase/supabase-js/src/lib/SupabaseRealtimeClient.ts"],"sourcesContent":["import { RealtimeSubscription, RealtimeClient, Transformers } from '@supabase/realtime-js'\nimport { GenericObject, SupabaseEventTypes, SupabaseRealtimePayload } from './types'\n\nexport class SupabaseRealtimeClient {\n  subscription: RealtimeSubscription\n\n  constructor(socket: RealtimeClient, headers: GenericObject, schema: string, tableName: string) {\n    const chanParams: GenericObject = {}\n    const topic = tableName === '*' ? `realtime:${schema}` : `realtime:${schema}:${tableName}`\n    const userToken = headers['Authorization'].split(' ')[1]\n\n    if (userToken) {\n      chanParams['user_token'] = userToken\n    }\n\n    this.subscription = socket.channel(topic, chanParams) as RealtimeSubscription\n  }\n\n  private getPayloadRecords(payload: any) {\n    const records = {\n      new: {},\n      old: {},\n    }\n\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n      records.new = Transformers.convertChangeData(payload.columns, payload.record)\n    }\n\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n      records.old = Transformers.convertChangeData(payload.columns, payload.old_record)\n    }\n\n    return records\n  }\n\n  /**\n   * The event you want to listen to.\n   *\n   * @param event The event\n   * @param callback A callback function that is called whenever the event occurs.\n   */\n  on(event: SupabaseEventTypes, callback: (payload: SupabaseRealtimePayload<any>) => void) {\n    this.subscription.on(event, (payload: any) => {\n      let enrichedPayload: SupabaseRealtimePayload<any> = {\n        schema: payload.schema,\n        table: payload.table,\n        commit_timestamp: payload.commit_timestamp,\n        eventType: payload.type,\n        new: {},\n        old: {},\n        errors: payload.errors,\n      }\n\n      enrichedPayload = { ...enrichedPayload, ...this.getPayloadRecords(payload) }\n\n      callback(enrichedPayload)\n    })\n    return this\n  }\n\n  /**\n   * Enables the subscription.\n   */\n  subscribe(callback: Function = () => {}) {\n    this.subscription.onError((e: Error) => callback('SUBSCRIPTION_ERROR', e))\n    this.subscription.onClose(() => callback('CLOSED'))\n    this.subscription\n      .subscribe()\n      .receive('ok', () => callback('SUBSCRIBED'))\n      .receive('error', (e: Error) => callback('SUBSCRIPTION_ERROR', e))\n      .receive('timeout', () => callback('RETRYING_AFTER_TIMEOUT'))\n    return this.subscription\n  }\n}\n"],"mappings":"AAAA,SAA+CA,YAAY,QAAQ,uBAAuB;AAG1F,OAAM,MAAOC,sBAAsB;EAGjCC,YAAYC,MAAsB,EAAEC,OAAsB,EAAEC,MAAc,EAAEC,SAAiB;IAC3F,MAAMC,UAAU,GAAkB,EAAE;IACpC,MAAMC,KAAK,GAAGF,SAAS,KAAK,GAAG,GAAG,YAAYD,MAAM,EAAE,GAAG,YAAYA,MAAM,IAAIC,SAAS,EAAE;IAC1F,MAAMG,SAAS,GAAGL,OAAO,CAAC,eAAe,CAAC,CAACM,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IAExD,IAAID,SAAS,EAAE;MACbF,UAAU,CAAC,YAAY,CAAC,GAAGE,SAAS;;IAGtC,IAAI,CAACE,YAAY,GAAGR,MAAM,CAACS,OAAO,CAACJ,KAAK,EAAED,UAAU,CAAyB;EAC/E;EAEQM,iBAAiBA,CAACC,OAAY;IACpC,MAAMC,OAAO,GAAG;MACdC,GAAG,EAAE,EAAE;MACPC,GAAG,EAAE;KACN;IAED,IAAIH,OAAO,CAACI,IAAI,KAAK,QAAQ,IAAIJ,OAAO,CAACI,IAAI,KAAK,QAAQ,EAAE;MAC1DH,OAAO,CAACC,GAAG,GAAGhB,YAAY,CAACmB,iBAAiB,CAACL,OAAO,CAACM,OAAO,EAAEN,OAAO,CAACO,MAAM,CAAC;;IAG/E,IAAIP,OAAO,CAACI,IAAI,KAAK,QAAQ,IAAIJ,OAAO,CAACI,IAAI,KAAK,QAAQ,EAAE;MAC1DH,OAAO,CAACE,GAAG,GAAGjB,YAAY,CAACmB,iBAAiB,CAACL,OAAO,CAACM,OAAO,EAAEN,OAAO,CAACQ,UAAU,CAAC;;IAGnF,OAAOP,OAAO;EAChB;EAEA;;;;;;EAMAQ,EAAEA,CAACC,KAAyB,EAAEC,QAAyD;IACrF,IAAI,CAACd,YAAY,CAACY,EAAE,CAACC,KAAK,EAAGV,OAAY,IAAI;MAC3C,IAAIY,eAAe,GAAiC;QAClDrB,MAAM,EAAES,OAAO,CAACT,MAAM;QACtBsB,KAAK,EAAEb,OAAO,CAACa,KAAK;QACpBC,gBAAgB,EAAEd,OAAO,CAACc,gBAAgB;QAC1CC,SAAS,EAAEf,OAAO,CAACI,IAAI;QACvBF,GAAG,EAAE,EAAE;QACPC,GAAG,EAAE,EAAE;QACPa,MAAM,EAAEhB,OAAO,CAACgB;OACjB;MAEDJ,eAAe,GAAAK,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAQN,eAAe,GAAK,IAAI,CAACb,iBAAiB,CAACC,OAAO,CAAC,CAAE;MAE5EW,QAAQ,CAACC,eAAe,CAAC;IAC3B,CAAC,CAAC;IACF,OAAO,IAAI;EACb;EAEA;;;EAGAO,SAASA,CAAA,EAA8B;IAAA,IAA7BR,QAAA,GAAAS,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAqB,MAAK,CAAE,CAAC;IACrC,IAAI,CAACvB,YAAY,CAAC0B,OAAO,CAAEC,CAAQ,IAAKb,QAAQ,CAAC,oBAAoB,EAAEa,CAAC,CAAC,CAAC;IAC1E,IAAI,CAAC3B,YAAY,CAAC4B,OAAO,CAAC,MAAMd,QAAQ,CAAC,QAAQ,CAAC,CAAC;IACnD,IAAI,CAACd,YAAY,CACdsB,SAAS,EAAE,CACXO,OAAO,CAAC,IAAI,EAAE,MAAMf,QAAQ,CAAC,YAAY,CAAC,CAAC,CAC3Ce,OAAO,CAAC,OAAO,EAAGF,CAAQ,IAAKb,QAAQ,CAAC,oBAAoB,EAAEa,CAAC,CAAC,CAAC,CACjEE,OAAO,CAAC,SAAS,EAAE,MAAMf,QAAQ,CAAC,wBAAwB,CAAC,CAAC;IAC/D,OAAO,IAAI,CAACd,YAAY;EAC1B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}