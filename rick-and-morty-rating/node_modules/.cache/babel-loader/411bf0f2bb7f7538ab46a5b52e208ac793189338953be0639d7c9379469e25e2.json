{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport GoTrueApi from './GoTrueApi';\nimport { isBrowser, getParameterByName, uuid, setItemAsync, removeItemAsync, getItemSynchronously, getItemAsync } from './lib/helpers';\nimport { GOTRUE_URL, DEFAULT_HEADERS, STORAGE_KEY, EXPIRY_MARGIN, NETWORK_FAILURE } from './lib/constants';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\nconst DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  multiTab: true,\n  headers: DEFAULT_HEADERS\n};\nconst decodeBase64URL = value => {\n  try {\n    // atob is present in all browsers and nodejs >= 16\n    // but if it is not it will throw a ReferenceError in which case we can try to use Buffer\n    // replace are here to convert the Base64-URL into Base64 which is what atob supports\n    // replace with //g regex acts like replaceAll\n    return atob(value.replace(/[-]/g, '+').replace(/[_]/g, '/'));\n  } catch (e) {\n    if (e instanceof ReferenceError) {\n      // running on nodejs < 16\n      // Buffer supports Base64-URL transparently\n      return Buffer.from(value, 'base64').toString('utf-8');\n    } else {\n      throw e;\n    }\n  }\n};\nexport default class GoTrueClient {\n  /**\n   * Create a new client for use in the browser.\n   * @param options.url The URL of the GoTrue server.\n   * @param options.headers Any additional headers to send to the GoTrue server.\n   * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.localStorage Provide your own local storage implementation to use instead of the browser's local storage.\n   * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n   * @param options.cookieOptions\n   * @param options.fetch A custom fetch implementation.\n   */\n  constructor(options) {\n    this.stateChangeEmitters = new Map();\n    this.networkRetries = 0;\n    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.currentUser = null;\n    this.currentSession = null;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.multiTab = settings.multiTab;\n    this.localStorage = settings.localStorage || globalThis.localStorage;\n    this.api = new GoTrueApi({\n      url: settings.url,\n      headers: settings.headers,\n      cookieOptions: settings.cookieOptions,\n      fetch: settings.fetch\n    });\n    this._recoverSession();\n    this._recoverAndRefresh();\n    this._listenForMultiTabEvents();\n    this._handleVisibilityChange();\n    if (settings.detectSessionInUrl && isBrowser() && !!getParameterByName('access_token')) {\n      // Handle the OAuth redirect\n      this.getSessionFromUrl({\n        storeSession: true\n      }).then(_ref => {\n        let {\n          error\n        } = _ref;\n        if (error) {\n          throw new Error('Error getting session from URL.');\n        }\n      });\n    }\n  }\n  /**\n   * Creates a new user.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param password The user's password.\n   * @param phone The user's phone number.\n   * @param redirectTo The redirect URL attached to the signup confirmation link. Does not redirect the user if it's a mobile signup.\n   * @param data Optional user metadata.\n   */\n  signUp(_ref2) {\n    let {\n      email,\n      password,\n      phone\n    } = _ref2;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this._removeSession();\n        const {\n          data,\n          error\n        } = phone && password ? yield this.api.signUpWithPhone(phone, password, {\n          data: options.data,\n          captchaToken: options.captchaToken\n        }) : yield this.api.signUpWithEmail(email, password, {\n          redirectTo: options.redirectTo,\n          data: options.data,\n          captchaToken: options.captchaToken\n        });\n        if (error) {\n          throw error;\n        }\n        if (!data) {\n          throw 'An error occurred on sign up.';\n        }\n        let session = null;\n        let user = null;\n        if (data.access_token) {\n          session = data;\n          user = session.user;\n          this._saveSession(session);\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n        if (data.id) {\n          user = data;\n        }\n        return {\n          user,\n          session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Log in an existing user, or login via a third-party provider.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param phone The user's phone number.\n   * @param password The user's password.\n   * @param refreshToken A valid refresh token that was returned on login.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL to send the user to after they are confirmed (OAuth logins only).\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n  signIn(_ref3) {\n    let {\n      email,\n      phone,\n      password,\n      refreshToken,\n      provider,\n      oidc\n    } = _ref3;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this._removeSession();\n        if (email && !password) {\n          const {\n            error\n          } = yield this.api.sendMagicLinkEmail(email, {\n            redirectTo: options.redirectTo,\n            shouldCreateUser: options.shouldCreateUser,\n            captchaToken: options.captchaToken\n          });\n          return {\n            user: null,\n            session: null,\n            error\n          };\n        }\n        if (email && password) {\n          return this._handleEmailSignIn(email, password, {\n            redirectTo: options.redirectTo,\n            captchaToken: options.captchaToken\n          });\n        }\n        if (phone && !password) {\n          const {\n            error\n          } = yield this.api.sendMobileOTP(phone, {\n            shouldCreateUser: options.shouldCreateUser,\n            captchaToken: options.captchaToken\n          });\n          return {\n            user: null,\n            session: null,\n            error\n          };\n        }\n        if (phone && password) {\n          return this._handlePhoneSignIn(phone, password);\n        }\n        if (refreshToken) {\n          // currentSession and currentUser will be updated to latest on _callRefreshToken using the passed refreshToken\n          const {\n            error\n          } = yield this._callRefreshToken(refreshToken);\n          if (error) throw error;\n          return {\n            user: this.currentUser,\n            session: this.currentSession,\n            error: null\n          };\n        }\n        if (provider) {\n          return this._handleProviderSignIn(provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes,\n            queryParams: options.queryParams\n          });\n        }\n        if (oidc) {\n          return this._handleOpenIDConnectSignIn(oidc);\n        }\n        throw new Error(`You must provide either an email, phone number, a third-party provider or OpenID Connect.`);\n      } catch (e) {\n        return {\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Log in a user given a User supplied OTP received via mobile.\n   * @param email The user's email address.\n   * @param phone The user's phone number.\n   * @param token The user's password.\n   * @param type The user's verification type.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  verifyOTP(params) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this._removeSession();\n        const {\n          data,\n          error\n        } = yield this.api.verifyOTP(params, options);\n        if (error) {\n          throw error;\n        }\n        if (!data) {\n          throw 'An error occurred on token verification.';\n        }\n        let session = null;\n        let user = null;\n        if (data.access_token) {\n          session = data;\n          user = session.user;\n          this._saveSession(session);\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n        if (data.id) {\n          user = data;\n        }\n        return {\n          user,\n          session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Inside a browser context, `user()` will return the user data, if there is a logged in user.\n   *\n   * For server-side management, you can get a user through `auth.api.getUserByCookie()`\n   */\n  user() {\n    return this.currentUser;\n  }\n  /**\n   * Returns the session data, if there is an active session.\n   */\n  session() {\n    return this.currentSession;\n  }\n  /**\n   * Force refreshes the session including the user data in case it was updated in a different session.\n   */\n  refreshSession() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token)) throw new Error('Not logged in.');\n        // currentSession and currentUser will be updated to latest on _callRefreshToken\n        const {\n          error\n        } = yield this._callRefreshToken();\n        if (error) throw error;\n        return {\n          data: this.currentSession,\n          user: this.currentUser,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Updates user data, if there is a logged in user.\n   */\n  update(attributes) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token)) throw new Error('Not logged in.');\n        const {\n          user,\n          error\n        } = yield this.api.updateUser(this.currentSession.access_token, attributes);\n        if (error) throw error;\n        if (!user) throw Error('Invalid user data.');\n        const session = Object.assign(Object.assign({}, this.currentSession), {\n          user\n        });\n        this._saveSession(session);\n        this._notifyAllSubscribers('USER_UPDATED');\n        return {\n          data: user,\n          user,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          error: e\n        };\n      }\n    });\n  }\n  setSession(arg0) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let session;\n      if (typeof arg0 === 'string') {\n        // using the refresh_token string API\n        const refresh_token = arg0;\n        const {\n          data,\n          error\n        } = yield this.api.refreshAccessToken(refresh_token);\n        if (error) {\n          return {\n            session: null,\n            error: error\n          };\n        }\n        session = data;\n      } else {\n        // using the object parameter API\n        const timeNow = Math.round(Date.now() / 1000);\n        let {\n          refresh_token,\n          access_token\n        } = arg0;\n        let expires_at = 0;\n        let expires_in = 0;\n        const tokenParts = access_token.split('.');\n        if (tokenParts.length !== 3) throw new Error('access_token is not a proper JWT');\n        const bodyJSON = decodeBase64URL(tokenParts[1]);\n        let parsed = undefined;\n        try {\n          parsed = JSON.parse(bodyJSON);\n        } catch (e) {\n          throw new Error('access_token is not a proper JWT, invalid JSON in body');\n        }\n        if (typeof parsed === 'object' && parsed && typeof parsed.exp === 'number') {\n          expires_at = parsed.exp;\n          expires_in = timeNow - parsed.exp;\n        } else {\n          throw new Error('access_token is not a proper JWT, missing exp claim');\n        }\n        if (timeNow > expires_at) {\n          const {\n            data,\n            error\n          } = yield this.api.refreshAccessToken(refresh_token);\n          if (error) {\n            return {\n              session: null,\n              error: error\n            };\n          }\n          session = data;\n        } else {\n          const {\n            user,\n            error\n          } = yield this.api.getUser(access_token);\n          if (error) throw error;\n          session = {\n            access_token,\n            expires_in,\n            expires_at,\n            refresh_token,\n            token_type: 'bearer',\n            user: user\n          };\n        }\n      }\n      try {\n        this._saveSession(session);\n        this._notifyAllSubscribers('SIGNED_IN');\n        return {\n          session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          error: e,\n          session: null\n        };\n      }\n    });\n  }\n  /**\n   * Overrides the JWT on the current client. The JWT will then be sent in all subsequent network requests.\n   * @param access_token a jwt access token\n   */\n  setAuth(access_token) {\n    this.currentSession = Object.assign(Object.assign({}, this.currentSession), {\n      access_token,\n      token_type: 'bearer',\n      user: this.user()\n    });\n    this._notifyAllSubscribers('TOKEN_REFRESHED');\n    return this.currentSession;\n  }\n  /**\n   * Gets the session data from a URL string\n   * @param options.storeSession Optionally store the session in the browser\n   */\n  getSessionFromUrl(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!isBrowser()) throw new Error('No browser detected.');\n        const error_description = getParameterByName('error_description');\n        if (error_description) throw new Error(error_description);\n        const provider_token = getParameterByName('provider_token');\n        const provider_refresh_token = getParameterByName('provider_refresh_token');\n        const access_token = getParameterByName('access_token');\n        if (!access_token) throw new Error('No access_token detected.');\n        const expires_in = getParameterByName('expires_in');\n        if (!expires_in) throw new Error('No expires_in detected.');\n        const refresh_token = getParameterByName('refresh_token');\n        if (!refresh_token) throw new Error('No refresh_token detected.');\n        const token_type = getParameterByName('token_type');\n        if (!token_type) throw new Error('No token_type detected.');\n        const timeNow = Math.round(Date.now() / 1000);\n        const expires_at = timeNow + parseInt(expires_in);\n        const {\n          user,\n          error\n        } = yield this.api.getUser(access_token);\n        if (error) throw error;\n        const session = {\n          provider_token,\n          provider_refresh_token,\n          access_token,\n          expires_in: parseInt(expires_in),\n          expires_at,\n          refresh_token,\n          token_type,\n          user: user\n        };\n        if (options === null || options === void 0 ? void 0 : options.storeSession) {\n          this._saveSession(session);\n          const recoveryMode = getParameterByName('type');\n          this._notifyAllSubscribers('SIGNED_IN');\n          if (recoveryMode === 'recovery') {\n            this._notifyAllSubscribers('PASSWORD_RECOVERY');\n          }\n        }\n        // Remove tokens from URL\n        window.location.hash = '';\n        return {\n          data: session,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n   * and log them out - removing all items from localstorage and then trigger a \"SIGNED_OUT\" event.\n   *\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`. There is no way to revoke a user's session JWT before it automatically expires\n   */\n  signOut() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const accessToken = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token;\n      this._removeSession();\n      this._notifyAllSubscribers('SIGNED_OUT');\n      if (accessToken) {\n        const {\n          error\n        } = yield this.api.signOut(accessToken);\n        if (error) return {\n          error\n        };\n      }\n      return {\n        error: null\n      };\n    });\n  }\n  /**\n   * Receive a notification every time an auth event happens.\n   * @returns {Subscription} A subscription object which can be used to unsubscribe itself.\n   */\n  onAuthStateChange(callback) {\n    try {\n      const id = uuid();\n      const subscription = {\n        id,\n        callback,\n        unsubscribe: () => {\n          this.stateChangeEmitters.delete(id);\n        }\n      };\n      this.stateChangeEmitters.set(id, subscription);\n      return {\n        data: subscription,\n        error: null\n      };\n    } catch (e) {\n      return {\n        data: null,\n        error: e\n      };\n    }\n  }\n  _handleEmailSignIn(email, password) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data,\n          error\n        } = yield this.api.signInWithEmail(email, password, {\n          redirectTo: options.redirectTo,\n          captchaToken: options.captchaToken\n        });\n        if (error || !data) return {\n          data: null,\n          user: null,\n          session: null,\n          error\n        };\n        if (((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.confirmed_at) || ((_b = data === null || data === void 0 ? void 0 : data.user) === null || _b === void 0 ? void 0 : _b.email_confirmed_at)) {\n          this._saveSession(data);\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n        return {\n          data,\n          user: data.user,\n          session: data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n  _handlePhoneSignIn(phone, password) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const {\n          data,\n          error\n        } = yield this.api.signInWithPhone(phone, password, options);\n        if (error || !data) return {\n          data: null,\n          user: null,\n          session: null,\n          error\n        };\n        if ((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.phone_confirmed_at) {\n          this._saveSession(data);\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n        return {\n          data,\n          user: data.user,\n          session: data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    });\n  }\n  _handleProviderSignIn(provider) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const url = this.api.getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes,\n      queryParams: options.queryParams\n    });\n    try {\n      // try to open on the browser\n      if (isBrowser()) {\n        window.location.href = url;\n      }\n      return {\n        provider,\n        url,\n        data: null,\n        session: null,\n        user: null,\n        error: null\n      };\n    } catch (e) {\n      // fallback to returning the URL\n      if (url) return {\n        provider,\n        url,\n        data: null,\n        session: null,\n        user: null,\n        error: null\n      };\n      return {\n        data: null,\n        user: null,\n        session: null,\n        error: e\n      };\n    }\n  }\n  _handleOpenIDConnectSignIn(_ref4) {\n    let {\n      id_token,\n      nonce,\n      client_id,\n      issuer,\n      provider\n    } = _ref4;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (id_token && nonce && (client_id && issuer || provider)) {\n        try {\n          const {\n            data,\n            error\n          } = yield this.api.signInWithOpenIDConnect({\n            id_token,\n            nonce,\n            client_id,\n            issuer,\n            provider\n          });\n          if (error || !data) return {\n            user: null,\n            session: null,\n            error\n          };\n          this._saveSession(data);\n          this._notifyAllSubscribers('SIGNED_IN');\n          return {\n            user: data.user,\n            session: data,\n            error: null\n          };\n        } catch (e) {\n          return {\n            user: null,\n            session: null,\n            error: e\n          };\n        }\n      }\n      throw new Error(`You must provide a OpenID Connect provider with your id token and nonce.`);\n    });\n  }\n  /**\n   * Attempts to get the session from LocalStorage\n   * Note: this should never be async (even for React Native), as we need it to return immediately in the constructor.\n   */\n  _recoverSession() {\n    try {\n      const data = getItemSynchronously(this.localStorage, STORAGE_KEY);\n      if (!data) return null;\n      const {\n        currentSession,\n        expiresAt\n      } = data;\n      const timeNow = Math.round(Date.now() / 1000);\n      if (expiresAt >= timeNow + EXPIRY_MARGIN && (currentSession === null || currentSession === void 0 ? void 0 : currentSession.user)) {\n        this._saveSession(currentSession);\n        this._notifyAllSubscribers('SIGNED_IN');\n      }\n    } catch (error) {\n      console.log('error', error);\n    }\n  }\n  /**\n   * Recovers the session from LocalStorage and refreshes\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n  _recoverAndRefresh() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield getItemAsync(this.localStorage, STORAGE_KEY);\n        if (!data) return null;\n        const {\n          currentSession,\n          expiresAt\n        } = data;\n        const timeNow = Math.round(Date.now() / 1000);\n        if (expiresAt < timeNow + EXPIRY_MARGIN) {\n          if (this.autoRefreshToken && currentSession.refresh_token) {\n            this.networkRetries++;\n            const {\n              error\n            } = yield this._callRefreshToken(currentSession.refresh_token);\n            if (error) {\n              console.log(error.message);\n              if (error.message === NETWORK_FAILURE.ERROR_MESSAGE && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) {\n                if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n                this.refreshTokenTimer = setTimeout(() => this._recoverAndRefresh(), Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100 // exponential backoff\n                );\n                return;\n              }\n              yield this._removeSession();\n            }\n            this.networkRetries = 0;\n          } else {\n            this._removeSession();\n          }\n        } else if (!currentSession) {\n          console.log('Current session is missing data.');\n          this._removeSession();\n        } else {\n          // should be handled on _recoverSession method already\n          // But we still need the code here to accommodate for AsyncStorage e.g. in React native\n          this._saveSession(currentSession);\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n      } catch (err) {\n        console.error(err);\n        return null;\n      }\n    });\n  }\n  _callRefreshToken(refresh_token) {\n    var _a;\n    if (refresh_token === void 0) {\n      refresh_token = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.refresh_token;\n    }\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!refresh_token) {\n          throw new Error('No current session.');\n        }\n        const {\n          data,\n          error\n        } = yield this.api.refreshAccessToken(refresh_token);\n        if (error) throw error;\n        if (!data) throw Error('Invalid session data.');\n        this._saveSession(data);\n        this._notifyAllSubscribers('TOKEN_REFRESHED');\n        this._notifyAllSubscribers('SIGNED_IN');\n        return {\n          data,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    });\n  }\n  _notifyAllSubscribers(event) {\n    this.stateChangeEmitters.forEach(x => x.callback(event, this.currentSession));\n  }\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n  _saveSession(session) {\n    this.currentSession = session;\n    this.currentUser = session.user;\n    const expiresAt = session.expires_at;\n    if (expiresAt) {\n      const timeNow = Math.round(Date.now() / 1000);\n      const expiresIn = expiresAt - timeNow;\n      const refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5;\n      this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);\n    }\n    // Do we need any extra check before persist session\n    // access_token or user ?\n    if (this.persistSession && session.expires_at) {\n      this._persistSession(this.currentSession);\n    }\n  }\n  _persistSession(currentSession) {\n    const data = {\n      currentSession,\n      expiresAt: currentSession.expires_at\n    };\n    setItemAsync(this.localStorage, STORAGE_KEY, data);\n  }\n  _removeSession() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.currentSession = null;\n      this.currentUser = null;\n      if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n      removeItemAsync(this.localStorage, STORAGE_KEY);\n    });\n  }\n  /**\n   * Clear and re-create refresh token timer\n   * @param value time intervals in milliseconds\n   */\n  _startAutoRefreshToken(value) {\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n    if (value <= 0 || !this.autoRefreshToken) return;\n    this.refreshTokenTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n      this.networkRetries++;\n      const {\n        error\n      } = yield this._callRefreshToken();\n      if (!error) this.networkRetries = 0;\n      if ((error === null || error === void 0 ? void 0 : error.message) === NETWORK_FAILURE.ERROR_MESSAGE && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) this._startAutoRefreshToken(Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100); // exponential backoff\n    }), value);\n    if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref();\n  }\n  /**\n   * Listens for changes to LocalStorage and updates the current session.\n   */\n  _listenForMultiTabEvents() {\n    if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n      return false;\n    }\n    try {\n      window === null || window === void 0 ? void 0 : window.addEventListener('storage', e => {\n        var _a;\n        if (e.key === STORAGE_KEY) {\n          const newSession = JSON.parse(String(e.newValue));\n          if ((_a = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) {\n            this._saveSession(newSession.currentSession);\n            this._notifyAllSubscribers('SIGNED_IN');\n          } else {\n            this._removeSession();\n            this._notifyAllSubscribers('SIGNED_OUT');\n          }\n        }\n      });\n    } catch (error) {\n      console.error('_listenForMultiTabEvents', error);\n    }\n  }\n  _handleVisibilityChange() {\n    if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n      return false;\n    }\n    try {\n      window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', () => {\n        if (document.visibilityState === 'visible') {\n          this._recoverAndRefresh();\n        }\n      });\n    } catch (error) {\n      console.error('_handleVisibilityChange', error);\n    }\n  }\n}","map":{"version":3,"names":["GoTrueApi","isBrowser","getParameterByName","uuid","setItemAsync","removeItemAsync","getItemSynchronously","getItemAsync","GOTRUE_URL","DEFAULT_HEADERS","STORAGE_KEY","EXPIRY_MARGIN","NETWORK_FAILURE","polyfillGlobalThis","DEFAULT_OPTIONS","url","autoRefreshToken","persistSession","detectSessionInUrl","multiTab","headers","decodeBase64URL","value","atob","replace","e","ReferenceError","Buffer","from","toString","GoTrueClient","constructor","options","stateChangeEmitters","Map","networkRetries","settings","Object","assign","currentUser","currentSession","localStorage","globalThis","api","cookieOptions","fetch","_recoverSession","_recoverAndRefresh","_listenForMultiTabEvents","_handleVisibilityChange","getSessionFromUrl","storeSession","then","_ref","error","Error","signUp","_ref2","email","password","phone","arguments","length","undefined","_removeSession","data","signUpWithPhone","captchaToken","signUpWithEmail","redirectTo","session","user","access_token","_saveSession","_notifyAllSubscribers","id","signIn","_ref3","refreshToken","provider","oidc","sendMagicLinkEmail","shouldCreateUser","_handleEmailSignIn","sendMobileOTP","_handlePhoneSignIn","_callRefreshToken","_handleProviderSignIn","scopes","queryParams","_handleOpenIDConnectSignIn","verifyOTP","params","refreshSession","_a","update","attributes","updateUser","setSession","arg0","refresh_token","refreshAccessToken","timeNow","Math","round","Date","now","expires_at","expires_in","tokenParts","split","bodyJSON","parsed","JSON","parse","exp","getUser","token_type","setAuth","error_description","provider_token","provider_refresh_token","parseInt","recoveryMode","window","location","hash","signOut","accessToken","onAuthStateChange","callback","subscription","unsubscribe","delete","set","signInWithEmail","confirmed_at","_b","email_confirmed_at","signInWithPhone","phone_confirmed_at","getUrlForProvider","href","_ref4","id_token","nonce","client_id","issuer","signInWithOpenIDConnect","expiresAt","console","log","message","ERROR_MESSAGE","MAX_RETRIES","refreshTokenTimer","clearTimeout","setTimeout","pow","RETRY_INTERVAL","err","event","forEach","x","expiresIn","refreshDurationBeforeExpires","_startAutoRefreshToken","_persistSession","__awaiter","unref","addEventListener","key","newSession","String","newValue","document","visibilityState"],"sources":["/workspaces/R-MPAGE/rick-and-morty-rating/node_modules/@supabase/gotrue-js/src/GoTrueClient.ts"],"sourcesContent":["import GoTrueApi from './GoTrueApi'\nimport {\n  isBrowser,\n  getParameterByName,\n  uuid,\n  setItemAsync,\n  removeItemAsync,\n  getItemSynchronously,\n  getItemAsync,\n} from './lib/helpers'\nimport {\n  GOTRUE_URL,\n  DEFAULT_HEADERS,\n  STORAGE_KEY,\n  EXPIRY_MARGIN,\n  NETWORK_FAILURE,\n} from './lib/constants'\nimport { polyfillGlobalThis } from './lib/polyfills'\nimport { Fetch } from './lib/fetch'\n\nimport type {\n  ApiError,\n  Session,\n  User,\n  UserAttributes,\n  Provider,\n  Subscription,\n  AuthChangeEvent,\n  CookieOptions,\n  UserCredentials,\n  VerifyOTPParams,\n  OpenIDConnectCredentials,\n  SupportedStorage,\n} from './lib/types'\n\npolyfillGlobalThis() // Make \"globalThis\" available\n\nconst DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  multiTab: true,\n  headers: DEFAULT_HEADERS,\n}\n\nconst decodeBase64URL = (value: string): string => {\n  try {\n    // atob is present in all browsers and nodejs >= 16\n    // but if it is not it will throw a ReferenceError in which case we can try to use Buffer\n    // replace are here to convert the Base64-URL into Base64 which is what atob supports\n    // replace with //g regex acts like replaceAll\n    return atob(value.replace(/[-]/g, '+').replace(/[_]/g, '/'))\n  } catch (e) {\n    if (e instanceof ReferenceError) {\n      // running on nodejs < 16\n      // Buffer supports Base64-URL transparently\n      return Buffer.from(value, 'base64').toString('utf-8')\n    } else {\n      throw e\n    }\n  }\n}\n\nexport default class GoTrueClient {\n  /**\n   * Namespace for the GoTrue API methods.\n   * These can be used for example to get a user from a JWT in a server environment or reset a user's password.\n   */\n  api: GoTrueApi\n  /**\n   * The currently logged in user or null.\n   */\n  protected currentUser: User | null\n  /**\n   * The session object for the currently logged in user or null.\n   */\n  protected currentSession: Session | null\n\n  protected autoRefreshToken: boolean\n  protected persistSession: boolean\n  protected localStorage: SupportedStorage\n  protected multiTab: boolean\n  protected stateChangeEmitters: Map<string, Subscription> = new Map()\n  protected refreshTokenTimer?: ReturnType<typeof setTimeout>\n  protected networkRetries: number = 0\n\n  /**\n   * Create a new client for use in the browser.\n   * @param options.url The URL of the GoTrue server.\n   * @param options.headers Any additional headers to send to the GoTrue server.\n   * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.localStorage Provide your own local storage implementation to use instead of the browser's local storage.\n   * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n   * @param options.cookieOptions\n   * @param options.fetch A custom fetch implementation.\n   */\n  constructor(options: {\n    url?: string\n    headers?: { [key: string]: string }\n    detectSessionInUrl?: boolean\n    autoRefreshToken?: boolean\n    persistSession?: boolean\n    localStorage?: SupportedStorage\n    multiTab?: boolean\n    cookieOptions?: CookieOptions\n    fetch?: Fetch\n  }) {\n    const settings = { ...DEFAULT_OPTIONS, ...options }\n    this.currentUser = null\n    this.currentSession = null\n    this.autoRefreshToken = settings.autoRefreshToken\n    this.persistSession = settings.persistSession\n    this.multiTab = settings.multiTab\n    this.localStorage = settings.localStorage || globalThis.localStorage\n    this.api = new GoTrueApi({\n      url: settings.url,\n      headers: settings.headers,\n      cookieOptions: settings.cookieOptions,\n      fetch: settings.fetch,\n    })\n    this._recoverSession()\n    this._recoverAndRefresh()\n    this._listenForMultiTabEvents()\n    this._handleVisibilityChange()\n\n    if (settings.detectSessionInUrl && isBrowser() && !!getParameterByName('access_token')) {\n      // Handle the OAuth redirect\n      this.getSessionFromUrl({ storeSession: true }).then(({ error }) => {\n        if (error) {\n          throw new Error('Error getting session from URL.')\n        }\n      })\n    }\n  }\n\n  /**\n   * Creates a new user.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param password The user's password.\n   * @param phone The user's phone number.\n   * @param redirectTo The redirect URL attached to the signup confirmation link. Does not redirect the user if it's a mobile signup.\n   * @param data Optional user metadata.\n   */\n  async signUp(\n    { email, password, phone }: UserCredentials,\n    options: {\n      redirectTo?: string\n      data?: object\n      captchaToken?: string\n    } = {}\n  ): Promise<{\n    user: User | null\n    session: Session | null\n    error: ApiError | null\n  }> {\n    try {\n      this._removeSession()\n\n      const { data, error } =\n        phone && password\n          ? await this.api.signUpWithPhone(phone!, password!, {\n              data: options.data,\n              captchaToken: options.captchaToken,\n            })\n          : await this.api.signUpWithEmail(email!, password!, {\n              redirectTo: options.redirectTo,\n              data: options.data,\n              captchaToken: options.captchaToken,\n            })\n\n      if (error) {\n        throw error\n      }\n\n      if (!data) {\n        throw 'An error occurred on sign up.'\n      }\n\n      let session: Session | null = null\n      let user: User | null = null\n\n      if ((data as Session).access_token) {\n        session = data as Session\n        user = session.user as User\n        this._saveSession(session)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n\n      if ((data as User).id) {\n        user = data as User\n      }\n\n      return { user, session, error: null }\n    } catch (e) {\n      return { user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Log in an existing user, or login via a third-party provider.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param phone The user's phone number.\n   * @param password The user's password.\n   * @param refreshToken A valid refresh token that was returned on login.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL to send the user to after they are confirmed (OAuth logins only).\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n  async signIn(\n    { email, phone, password, refreshToken, provider, oidc }: UserCredentials,\n    options: {\n      redirectTo?: string\n      shouldCreateUser?: boolean\n      scopes?: string\n      captchaToken?: string\n      queryParams?: { [key: string]: string }\n    } = {}\n  ): Promise<{\n    session: Session | null\n    user: User | null\n    provider?: Provider\n    url?: string | null\n    error: ApiError | null\n  }> {\n    try {\n      this._removeSession()\n\n      if (email && !password) {\n        const { error } = await this.api.sendMagicLinkEmail(email, {\n          redirectTo: options.redirectTo,\n          shouldCreateUser: options.shouldCreateUser,\n          captchaToken: options.captchaToken,\n        })\n        return { user: null, session: null, error }\n      }\n      if (email && password) {\n        return this._handleEmailSignIn(email, password, {\n          redirectTo: options.redirectTo,\n          captchaToken: options.captchaToken,\n        })\n      }\n      if (phone && !password) {\n        const { error } = await this.api.sendMobileOTP(phone, {\n          shouldCreateUser: options.shouldCreateUser,\n          captchaToken: options.captchaToken,\n        })\n        return { user: null, session: null, error }\n      }\n      if (phone && password) {\n        return this._handlePhoneSignIn(phone, password)\n      }\n      if (refreshToken) {\n        // currentSession and currentUser will be updated to latest on _callRefreshToken using the passed refreshToken\n        const { error } = await this._callRefreshToken(refreshToken)\n        if (error) throw error\n\n        return {\n          user: this.currentUser,\n          session: this.currentSession,\n          error: null,\n        }\n      }\n      if (provider) {\n        return this._handleProviderSignIn(provider, {\n          redirectTo: options.redirectTo,\n          scopes: options.scopes,\n          queryParams: options.queryParams,\n        })\n      }\n      if (oidc) {\n        return this._handleOpenIDConnectSignIn(oidc)\n      }\n      throw new Error(\n        `You must provide either an email, phone number, a third-party provider or OpenID Connect.`\n      )\n    } catch (e) {\n      return { user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Log in a user given a User supplied OTP received via mobile.\n   * @param email The user's email address.\n   * @param phone The user's phone number.\n   * @param token The user's password.\n   * @param type The user's verification type.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async verifyOTP(\n    params: VerifyOTPParams,\n    options: {\n      redirectTo?: string\n    } = {}\n  ): Promise<{\n    user: User | null\n    session: Session | null\n    error: ApiError | null\n  }> {\n    try {\n      this._removeSession()\n\n      const { data, error } = await this.api.verifyOTP(params, options)\n\n      if (error) {\n        throw error\n      }\n\n      if (!data) {\n        throw 'An error occurred on token verification.'\n      }\n\n      let session: Session | null = null\n      let user: User | null = null\n\n      if ((data as Session).access_token) {\n        session = data as Session\n        user = session.user as User\n        this._saveSession(session)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n\n      if ((data as User).id) {\n        user = data as User\n      }\n\n      return { user, session, error: null }\n    } catch (e) {\n      return { user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Inside a browser context, `user()` will return the user data, if there is a logged in user.\n   *\n   * For server-side management, you can get a user through `auth.api.getUserByCookie()`\n   */\n  user(): User | null {\n    return this.currentUser\n  }\n\n  /**\n   * Returns the session data, if there is an active session.\n   */\n  session(): Session | null {\n    return this.currentSession\n  }\n\n  /**\n   * Force refreshes the session including the user data in case it was updated in a different session.\n   */\n  async refreshSession(): Promise<{\n    data: Session | null\n    user: User | null\n    error: ApiError | null\n  }> {\n    try {\n      if (!this.currentSession?.access_token) throw new Error('Not logged in.')\n\n      // currentSession and currentUser will be updated to latest on _callRefreshToken\n      const { error } = await this._callRefreshToken()\n      if (error) throw error\n\n      return { data: this.currentSession, user: this.currentUser, error: null }\n    } catch (e) {\n      return { data: null, user: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Updates user data, if there is a logged in user.\n   */\n  async update(\n    attributes: UserAttributes\n  ): Promise<{ data: User | null; user: User | null; error: ApiError | null }> {\n    try {\n      if (!this.currentSession?.access_token) throw new Error('Not logged in.')\n\n      const { user, error } = await this.api.updateUser(\n        this.currentSession.access_token,\n        attributes\n      )\n      if (error) throw error\n      if (!user) throw Error('Invalid user data.')\n\n      const session = { ...this.currentSession, user }\n      this._saveSession(session)\n      this._notifyAllSubscribers('USER_UPDATED')\n\n      return { data: user, user, error: null }\n    } catch (e) {\n      return { data: null, user: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sets the session from the provided session information. The access_token\n   * is reused if it is not expired, otherwise a new access token is fetched by\n   * refreshing the session with the provided refresh_token.\n   *\n   * This method is useful when using in a server-side rendered context.\n   *\n   * @param params.refresh_token A valid refresh token (typically obtained from a cookie)\n   * @param params.access_token An access token (typically obtained from a cookie)\n   */\n  async setSession(params: {\n    refresh_token: string\n    access_token: string\n  }): Promise<{ session: Session | null; error: ApiError | null }>\n\n  /**\n   * Sets the session data from refresh_token and returns current Session and Error\n   * @param refresh_token a JWT token\n   */\n  async setSession(\n    refresh_token: string\n  ): Promise<{ session: Session | null; error: ApiError | null }>\n\n  async setSession(\n    arg0: string | { access_token: string; refresh_token: string }\n  ): Promise<{ session: Session | null; error: ApiError | null }> {\n    let session: Session\n\n    if (typeof arg0 === 'string') {\n      // using the refresh_token string API\n      const refresh_token = arg0\n\n      const { data, error } = await this.api.refreshAccessToken(refresh_token)\n      if (error) {\n        return { session: null, error: error }\n      }\n\n      session = data!\n    } else {\n      // using the object parameter API\n\n      const timeNow = Math.round(Date.now() / 1000)\n\n      let { refresh_token, access_token } = arg0\n      let expires_at = 0\n      let expires_in = 0\n\n      const tokenParts = access_token.split('.')\n      if (tokenParts.length !== 3) throw new Error('access_token is not a proper JWT')\n\n      const bodyJSON = decodeBase64URL(tokenParts[1])\n\n      let parsed: any = undefined\n      try {\n        parsed = JSON.parse(bodyJSON)\n      } catch (e) {\n        throw new Error('access_token is not a proper JWT, invalid JSON in body')\n      }\n\n      if (typeof parsed === 'object' && parsed && typeof parsed.exp === 'number') {\n        expires_at = parsed.exp\n        expires_in = timeNow - parsed.exp\n      } else {\n        throw new Error('access_token is not a proper JWT, missing exp claim')\n      }\n\n      if (timeNow > expires_at) {\n        const { data, error } = await this.api.refreshAccessToken(refresh_token)\n        if (error) {\n          return { session: null, error: error }\n        }\n\n        session = data!\n      } else {\n        const { user, error } = await this.api.getUser(access_token)\n        if (error) throw error\n\n        session = {\n          access_token,\n          expires_in,\n          expires_at,\n          refresh_token,\n          token_type: 'bearer',\n          user: user!,\n        }\n      }\n    }\n\n    try {\n      this._saveSession(session)\n      this._notifyAllSubscribers('SIGNED_IN')\n      return { session, error: null }\n    } catch (e) {\n      return { error: e as ApiError, session: null }\n    }\n  }\n\n  /**\n   * Overrides the JWT on the current client. The JWT will then be sent in all subsequent network requests.\n   * @param access_token a jwt access token\n   */\n  setAuth(access_token: string): Session {\n    this.currentSession = {\n      ...this.currentSession,\n      access_token,\n      token_type: 'bearer',\n      user: this.user(),\n    }\n\n    this._notifyAllSubscribers('TOKEN_REFRESHED')\n\n    return this.currentSession\n  }\n\n  /**\n   * Gets the session data from a URL string\n   * @param options.storeSession Optionally store the session in the browser\n   */\n  async getSessionFromUrl(options?: {\n    storeSession?: boolean\n  }): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      if (!isBrowser()) throw new Error('No browser detected.')\n\n      const error_description = getParameterByName('error_description')\n      if (error_description) throw new Error(error_description)\n\n      const provider_token = getParameterByName('provider_token')\n      const provider_refresh_token = getParameterByName('provider_refresh_token')\n      const access_token = getParameterByName('access_token')\n      if (!access_token) throw new Error('No access_token detected.')\n      const expires_in = getParameterByName('expires_in')\n      if (!expires_in) throw new Error('No expires_in detected.')\n      const refresh_token = getParameterByName('refresh_token')\n      if (!refresh_token) throw new Error('No refresh_token detected.')\n      const token_type = getParameterByName('token_type')\n      if (!token_type) throw new Error('No token_type detected.')\n\n      const timeNow = Math.round(Date.now() / 1000)\n      const expires_at = timeNow + parseInt(expires_in)\n\n      const { user, error } = await this.api.getUser(access_token)\n      if (error) throw error\n\n      const session: Session = {\n        provider_token,\n        provider_refresh_token,\n        access_token,\n        expires_in: parseInt(expires_in),\n        expires_at,\n        refresh_token,\n        token_type,\n        user: user!,\n      }\n      if (options?.storeSession) {\n        this._saveSession(session)\n        const recoveryMode = getParameterByName('type')\n        this._notifyAllSubscribers('SIGNED_IN')\n        if (recoveryMode === 'recovery') {\n          this._notifyAllSubscribers('PASSWORD_RECOVERY')\n        }\n      }\n      // Remove tokens from URL\n      window.location.hash = ''\n\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n   * and log them out - removing all items from localstorage and then trigger a \"SIGNED_OUT\" event.\n   *\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`. There is no way to revoke a user's session JWT before it automatically expires\n   */\n  async signOut(): Promise<{ error: ApiError | null }> {\n    const accessToken = this.currentSession?.access_token\n    this._removeSession()\n    this._notifyAllSubscribers('SIGNED_OUT')\n    if (accessToken) {\n      const { error } = await this.api.signOut(accessToken)\n      if (error) return { error }\n    }\n    return { error: null }\n  }\n\n  /**\n   * Receive a notification every time an auth event happens.\n   * @returns {Subscription} A subscription object which can be used to unsubscribe itself.\n   */\n  onAuthStateChange(callback: (event: AuthChangeEvent, session: Session | null) => void): {\n    data: Subscription | null\n    error: ApiError | null\n  } {\n    try {\n      const id: string = uuid()\n      const subscription: Subscription = {\n        id,\n        callback,\n        unsubscribe: () => {\n          this.stateChangeEmitters.delete(id)\n        },\n      }\n      this.stateChangeEmitters.set(id, subscription)\n      return { data: subscription, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  private async _handleEmailSignIn(\n    email: string,\n    password: string,\n    options: {\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ) {\n    try {\n      const { data, error } = await this.api.signInWithEmail(email, password, {\n        redirectTo: options.redirectTo,\n        captchaToken: options.captchaToken,\n      })\n      if (error || !data) return { data: null, user: null, session: null, error }\n\n      if (data?.user?.confirmed_at || data?.user?.email_confirmed_at) {\n        this._saveSession(data)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n\n      return { data, user: data.user, session: data, error: null }\n    } catch (e) {\n      return { data: null, user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  private async _handlePhoneSignIn(\n    phone: string,\n    password: string,\n    options: {\n      captchaToken?: string\n    } = {}\n  ) {\n    try {\n      const { data, error } = await this.api.signInWithPhone(phone, password, options)\n      if (error || !data) return { data: null, user: null, session: null, error }\n\n      if (data?.user?.phone_confirmed_at) {\n        this._saveSession(data)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n\n      return { data, user: data.user, session: data, error: null }\n    } catch (e) {\n      return { data: null, user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  private _handleProviderSignIn(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n      queryParams?: { [key: string]: string }\n    } = {}\n  ) {\n    const url: string = this.api.getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes,\n      queryParams: options.queryParams,\n    })\n\n    try {\n      // try to open on the browser\n      if (isBrowser()) {\n        window.location.href = url\n      }\n      return { provider, url, data: null, session: null, user: null, error: null }\n    } catch (e) {\n      // fallback to returning the URL\n      if (url) return { provider, url, data: null, session: null, user: null, error: null }\n      return { data: null, user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  private async _handleOpenIDConnectSignIn({\n    id_token,\n    nonce,\n    client_id,\n    issuer,\n    provider,\n  }: OpenIDConnectCredentials): Promise<{\n    session: Session | null\n    user: User | null\n    error: ApiError | null\n  }> {\n    if (id_token && nonce && ((client_id && issuer) || provider)) {\n      try {\n        const { data, error } = await this.api.signInWithOpenIDConnect({\n          id_token,\n          nonce,\n          client_id,\n          issuer,\n          provider,\n        })\n        if (error || !data) return { user: null, session: null, error }\n        this._saveSession(data)\n        this._notifyAllSubscribers('SIGNED_IN')\n        return { user: data.user, session: data, error: null }\n      } catch (e) {\n        return { user: null, session: null, error: e as ApiError }\n      }\n    }\n    throw new Error(`You must provide a OpenID Connect provider with your id token and nonce.`)\n  }\n\n  /**\n   * Attempts to get the session from LocalStorage\n   * Note: this should never be async (even for React Native), as we need it to return immediately in the constructor.\n   */\n  private _recoverSession() {\n    try {\n      const data = getItemSynchronously(this.localStorage, STORAGE_KEY)\n      if (!data) return null\n      const { currentSession, expiresAt } = data\n      const timeNow = Math.round(Date.now() / 1000)\n\n      if (expiresAt >= timeNow + EXPIRY_MARGIN && currentSession?.user) {\n        this._saveSession(currentSession)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n    } catch (error) {\n      console.log('error', error)\n    }\n  }\n\n  /**\n   * Recovers the session from LocalStorage and refreshes\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n  private async _recoverAndRefresh() {\n    try {\n      const data = await getItemAsync(this.localStorage, STORAGE_KEY)\n      if (!data) return null\n      const { currentSession, expiresAt } = data\n      const timeNow = Math.round(Date.now() / 1000)\n\n      if (expiresAt < timeNow + EXPIRY_MARGIN) {\n        if (this.autoRefreshToken && currentSession.refresh_token) {\n          this.networkRetries++\n          const { error } = await this._callRefreshToken(currentSession.refresh_token)\n          if (error) {\n            console.log(error.message)\n            if (\n              error.message === NETWORK_FAILURE.ERROR_MESSAGE &&\n              this.networkRetries < NETWORK_FAILURE.MAX_RETRIES\n            ) {\n              if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\n              this.refreshTokenTimer = setTimeout(\n                () => this._recoverAndRefresh(),\n                NETWORK_FAILURE.RETRY_INTERVAL ** this.networkRetries * 100 // exponential backoff\n              )\n              return\n            }\n            await this._removeSession()\n          }\n          this.networkRetries = 0\n        } else {\n          this._removeSession()\n        }\n      } else if (!currentSession) {\n        console.log('Current session is missing data.')\n        this._removeSession()\n      } else {\n        // should be handled on _recoverSession method already\n        // But we still need the code here to accommodate for AsyncStorage e.g. in React native\n        this._saveSession(currentSession)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n    } catch (err) {\n      console.error(err)\n      return null\n    }\n  }\n\n  private async _callRefreshToken(refresh_token = this.currentSession?.refresh_token) {\n    try {\n      if (!refresh_token) {\n        throw new Error('No current session.')\n      }\n      const { data, error } = await this.api.refreshAccessToken(refresh_token)\n      if (error) throw error\n      if (!data) throw Error('Invalid session data.')\n\n      this._saveSession(data)\n      this._notifyAllSubscribers('TOKEN_REFRESHED')\n      this._notifyAllSubscribers('SIGNED_IN')\n\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  private _notifyAllSubscribers(event: AuthChangeEvent) {\n    this.stateChangeEmitters.forEach((x) => x.callback(event, this.currentSession))\n  }\n\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n  private _saveSession(session: Session) {\n    this.currentSession = session\n    this.currentUser = session.user\n\n    const expiresAt = session.expires_at\n    if (expiresAt) {\n      const timeNow = Math.round(Date.now() / 1000)\n      const expiresIn = expiresAt - timeNow\n      const refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5\n      this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000)\n    }\n\n    // Do we need any extra check before persist session\n    // access_token or user ?\n    if (this.persistSession && session.expires_at) {\n      this._persistSession(this.currentSession)\n    }\n  }\n\n  private _persistSession(currentSession: Session) {\n    const data = { currentSession, expiresAt: currentSession.expires_at }\n    setItemAsync(this.localStorage, STORAGE_KEY, data)\n  }\n\n  private async _removeSession() {\n    this.currentSession = null\n    this.currentUser = null\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\n    removeItemAsync(this.localStorage, STORAGE_KEY)\n  }\n\n  /**\n   * Clear and re-create refresh token timer\n   * @param value time intervals in milliseconds\n   */\n  private _startAutoRefreshToken(value: number) {\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\n    if (value <= 0 || !this.autoRefreshToken) return\n\n    this.refreshTokenTimer = setTimeout(async () => {\n      this.networkRetries++\n      const { error } = await this._callRefreshToken()\n      if (!error) this.networkRetries = 0\n      if (\n        error?.message === NETWORK_FAILURE.ERROR_MESSAGE &&\n        this.networkRetries < NETWORK_FAILURE.MAX_RETRIES\n      )\n        this._startAutoRefreshToken(NETWORK_FAILURE.RETRY_INTERVAL ** this.networkRetries * 100) // exponential backoff\n    }, value)\n    if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref()\n  }\n\n  /**\n   * Listens for changes to LocalStorage and updates the current session.\n   */\n  private _listenForMultiTabEvents() {\n    if (!this.multiTab || !isBrowser() || !window?.addEventListener) {\n      return false\n    }\n\n    try {\n      window?.addEventListener('storage', (e: StorageEvent) => {\n        if (e.key === STORAGE_KEY) {\n          const newSession = JSON.parse(String(e.newValue))\n          if (newSession?.currentSession?.access_token) {\n            this._saveSession(newSession.currentSession)\n            this._notifyAllSubscribers('SIGNED_IN')\n          } else {\n            this._removeSession()\n            this._notifyAllSubscribers('SIGNED_OUT')\n          }\n        }\n      })\n    } catch (error) {\n      console.error('_listenForMultiTabEvents', error)\n    }\n  }\n\n  private _handleVisibilityChange() {\n    if (!this.multiTab || !isBrowser() || !window?.addEventListener) {\n      return false\n    }\n\n    try {\n      window?.addEventListener('visibilitychange', () => {\n        if (document.visibilityState === 'visible') {\n          this._recoverAndRefresh()\n        }\n      })\n    } catch (error) {\n      console.error('_handleVisibilityChange', error)\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}