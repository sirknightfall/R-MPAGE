{"ast":null,"code":"import PostgrestTransformBuilder from './PostgrestTransformBuilder';\nexport default class PostgrestFilterBuilder extends PostgrestTransformBuilder {\n  constructor() {\n    super(...arguments);\n    /** @deprecated Use `contains()` instead. */\n    this.cs = this.contains;\n    /** @deprecated Use `containedBy()` instead. */\n    this.cd = this.containedBy;\n    /** @deprecated Use `rangeLt()` instead. */\n    this.sl = this.rangeLt;\n    /** @deprecated Use `rangeGt()` instead. */\n    this.sr = this.rangeGt;\n    /** @deprecated Use `rangeGte()` instead. */\n    this.nxl = this.rangeGte;\n    /** @deprecated Use `rangeLte()` instead. */\n    this.nxr = this.rangeLte;\n    /** @deprecated Use `rangeAdjacent()` instead. */\n    this.adj = this.rangeAdjacent;\n    /** @deprecated Use `overlaps()` instead. */\n    this.ov = this.overlaps;\n  }\n  /**\n   * Finds all rows which doesn't satisfy the filter.\n   *\n   * @param column  The column to filter on.\n   * @param operator  The operator to filter with.\n   * @param value  The value to filter with.\n   */\n  not(column, operator, value) {\n    this.url.searchParams.append(`${column}`, `not.${operator}.${value}`);\n    return this;\n  }\n  /**\n   * Finds all rows satisfying at least one of the filters.\n   *\n   * @param filters  The filters to use, separated by commas.\n   * @param foreignTable  The foreign table to use (if `column` is a foreign column).\n   */\n  or(filters) {\n    let {\n      foreignTable\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const key = typeof foreignTable === 'undefined' ? 'or' : `${foreignTable}.or`;\n    this.url.searchParams.append(key, `(${filters})`);\n    return this;\n  }\n  /**\n   * Finds all rows whose value on the stated `column` exactly matches the\n   * specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  eq(column, value) {\n    this.url.searchParams.append(`${column}`, `eq.${value}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose value on the stated `column` doesn't match the\n   * specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  neq(column, value) {\n    this.url.searchParams.append(`${column}`, `neq.${value}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose value on the stated `column` is greater than the\n   * specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  gt(column, value) {\n    this.url.searchParams.append(`${column}`, `gt.${value}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose value on the stated `column` is greater than or\n   * equal to the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  gte(column, value) {\n    this.url.searchParams.append(`${column}`, `gte.${value}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose value on the stated `column` is less than the\n   * specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  lt(column, value) {\n    this.url.searchParams.append(`${column}`, `lt.${value}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose value on the stated `column` is less than or equal\n   * to the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  lte(column, value) {\n    this.url.searchParams.append(`${column}`, `lte.${value}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose value in the stated `column` matches the supplied\n   * `pattern` (case sensitive).\n   *\n   * @param column  The column to filter on.\n   * @param pattern  The pattern to filter with.\n   */\n  like(column, pattern) {\n    this.url.searchParams.append(`${column}`, `like.${pattern}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose value in the stated `column` matches the supplied\n   * `pattern` (case insensitive).\n   *\n   * @param column  The column to filter on.\n   * @param pattern  The pattern to filter with.\n   */\n  ilike(column, pattern) {\n    this.url.searchParams.append(`${column}`, `ilike.${pattern}`);\n    return this;\n  }\n  /**\n   * A check for exact equality (null, true, false), finds all rows whose\n   * value on the stated `column` exactly match the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  is(column, value) {\n    this.url.searchParams.append(`${column}`, `is.${value}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose value on the stated `column` is found on the\n   * specified `values`.\n   *\n   * @param column  The column to filter on.\n   * @param values  The values to filter with.\n   */\n  in(column, values) {\n    const cleanedValues = values.map(s => {\n      // handle postgrest reserved characters\n      // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n      if (typeof s === 'string' && new RegExp('[,()]').test(s)) return `\"${s}\"`;else return `${s}`;\n    }).join(',');\n    this.url.searchParams.append(`${column}`, `in.(${cleanedValues})`);\n    return this;\n  }\n  /**\n   * Finds all rows whose json, array, or range value on the stated `column`\n   * contains the values specified in `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  contains(column, value) {\n    if (typeof value === 'string') {\n      // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n      // keep it simple and accept a string\n      this.url.searchParams.append(`${column}`, `cs.${value}`);\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(`${column}`, `cs.{${value.join(',')}}`);\n    } else {\n      // json\n      this.url.searchParams.append(`${column}`, `cs.${JSON.stringify(value)}`);\n    }\n    return this;\n  }\n  /**\n   * Finds all rows whose json, array, or range value on the stated `column` is\n   * contained by the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  containedBy(column, value) {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(`${column}`, `cd.${value}`);\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(`${column}`, `cd.{${value.join(',')}}`);\n    } else {\n      // json\n      this.url.searchParams.append(`${column}`, `cd.${JSON.stringify(value)}`);\n    }\n    return this;\n  }\n  /**\n   * Finds all rows whose range value on the stated `column` is strictly to the\n   * left of the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeLt(column, range) {\n    this.url.searchParams.append(`${column}`, `sl.${range}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose range value on the stated `column` is strictly to\n   * the right of the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeGt(column, range) {\n    this.url.searchParams.append(`${column}`, `sr.${range}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose range value on the stated `column` does not extend\n   * to the left of the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeGte(column, range) {\n    this.url.searchParams.append(`${column}`, `nxl.${range}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose range value on the stated `column` does not extend\n   * to the right of the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeLte(column, range) {\n    this.url.searchParams.append(`${column}`, `nxr.${range}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose range value on the stated `column` is adjacent to\n   * the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeAdjacent(column, range) {\n    this.url.searchParams.append(`${column}`, `adj.${range}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose array or range value on the stated `column` overlaps\n   * (has a value in common) with the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  overlaps(column, value) {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(`${column}`, `ov.${value}`);\n    } else {\n      // array\n      this.url.searchParams.append(`${column}`, `ov.{${value.join(',')}}`);\n    }\n    return this;\n  }\n  /**\n   * Finds all rows whose text or tsvector value on the stated `column` matches\n   * the tsquery in `query`.\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   * @param type  The type of tsquery conversion to use on `query`.\n   */\n  textSearch(column, query) {\n    let {\n      config,\n      type = null\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let typePart = '';\n    if (type === 'plain') {\n      typePart = 'pl';\n    } else if (type === 'phrase') {\n      typePart = 'ph';\n    } else if (type === 'websearch') {\n      typePart = 'w';\n    }\n    const configPart = config === undefined ? '' : `(${config})`;\n    this.url.searchParams.append(`${column}`, `${typePart}fts${configPart}.${query}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose tsvector value on the stated `column` matches\n   * to_tsquery(`query`).\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   *\n   * @deprecated Use `textSearch()` instead.\n   */\n  fts(column, query) {\n    let {\n      config\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`;\n    this.url.searchParams.append(`${column}`, `fts${configPart}.${query}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose tsvector value on the stated `column` matches\n   * plainto_tsquery(`query`).\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   *\n   * @deprecated Use `textSearch()` with `type: 'plain'` instead.\n   */\n  plfts(column, query) {\n    let {\n      config\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`;\n    this.url.searchParams.append(`${column}`, `plfts${configPart}.${query}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose tsvector value on the stated `column` matches\n   * phraseto_tsquery(`query`).\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   *\n   * @deprecated Use `textSearch()` with `type: 'phrase'` instead.\n   */\n  phfts(column, query) {\n    let {\n      config\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`;\n    this.url.searchParams.append(`${column}`, `phfts${configPart}.${query}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose tsvector value on the stated `column` matches\n   * websearch_to_tsquery(`query`).\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   *\n   * @deprecated Use `textSearch()` with `type: 'websearch'` instead.\n   */\n  wfts(column, query) {\n    let {\n      config\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`;\n    this.url.searchParams.append(`${column}`, `wfts${configPart}.${query}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose `column` satisfies the filter.\n   *\n   * @param column  The column to filter on.\n   * @param operator  The operator to filter with.\n   * @param value  The value to filter with.\n   */\n  filter(column, operator, value) {\n    this.url.searchParams.append(`${column}`, `${operator}.${value}`);\n    return this;\n  }\n  /**\n   * Finds all rows whose columns match the specified `query` object.\n   *\n   * @param query  The object to filter with, with column names as keys mapped\n   *               to their filter values.\n   */\n  match(query) {\n    Object.keys(query).forEach(key => {\n      this.url.searchParams.append(`${key}`, `eq.${query[key]}`);\n    });\n    return this;\n  }\n}","map":{"version":3,"names":["PostgrestTransformBuilder","PostgrestFilterBuilder","constructor","cs","contains","cd","containedBy","sl","rangeLt","sr","rangeGt","nxl","rangeGte","nxr","rangeLte","adj","rangeAdjacent","ov","overlaps","not","column","operator","value","url","searchParams","append","or","filters","foreignTable","arguments","length","undefined","key","eq","neq","gt","gte","lt","lte","like","pattern","ilike","is","in","values","cleanedValues","map","s","RegExp","test","join","Array","isArray","JSON","stringify","range","textSearch","query","config","type","typePart","configPart","fts","plfts","phfts","wfts","filter","match","Object","keys","forEach"],"sources":["/workspaces/R-MPAGE/rick-and-morty-rating/node_modules/@supabase/postgrest-js/src/lib/PostgrestFilterBuilder.ts"],"sourcesContent":["import PostgrestTransformBuilder from './PostgrestTransformBuilder'\n\n/**\n * Filters\n */\n\ntype FilterOperator =\n  | 'eq'\n  | 'neq'\n  | 'gt'\n  | 'gte'\n  | 'lt'\n  | 'lte'\n  | 'like'\n  | 'ilike'\n  | 'is'\n  | 'in'\n  | 'cs'\n  | 'cd'\n  | 'sl'\n  | 'sr'\n  | 'nxl'\n  | 'nxr'\n  | 'adj'\n  | 'ov'\n  | 'fts'\n  | 'plfts'\n  | 'phfts'\n  | 'wfts'\n  | 'not.eq'\n  | 'not.neq'\n  | 'not.gt'\n  | 'not.gte'\n  | 'not.lt'\n  | 'not.lte'\n  | 'not.like'\n  | 'not.ilike'\n  | 'not.is'\n  | 'not.in'\n  | 'not.cs'\n  | 'not.cd'\n  | 'not.sl'\n  | 'not.sr'\n  | 'not.nxl'\n  | 'not.nxr'\n  | 'not.adj'\n  | 'not.ov'\n  | 'not.fts'\n  | 'not.plfts'\n  | 'not.phfts'\n  | 'not.wfts'\n\nexport default class PostgrestFilterBuilder<T> extends PostgrestTransformBuilder<T> {\n  /**\n   * Finds all rows which doesn't satisfy the filter.\n   *\n   * @param column  The column to filter on.\n   * @param operator  The operator to filter with.\n   * @param value  The value to filter with.\n   */\n  not(column: keyof T, operator: FilterOperator, value: any): this {\n    this.url.searchParams.append(`${column}`, `not.${operator}.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows satisfying at least one of the filters.\n   *\n   * @param filters  The filters to use, separated by commas.\n   * @param foreignTable  The foreign table to use (if `column` is a foreign column).\n   */\n  or(filters: string, { foreignTable }: { foreignTable?: string } = {}): this {\n    const key = typeof foreignTable === 'undefined' ? 'or' : `${foreignTable}.or`\n    this.url.searchParams.append(key, `(${filters})`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value on the stated `column` exactly matches the\n   * specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  eq(column: keyof T, value: T[keyof T]): this {\n    this.url.searchParams.append(`${column}`, `eq.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value on the stated `column` doesn't match the\n   * specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  neq(column: keyof T, value: T[keyof T]): this {\n    this.url.searchParams.append(`${column}`, `neq.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value on the stated `column` is greater than the\n   * specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  gt(column: keyof T, value: T[keyof T]): this {\n    this.url.searchParams.append(`${column}`, `gt.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value on the stated `column` is greater than or\n   * equal to the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  gte(column: keyof T, value: T[keyof T]): this {\n    this.url.searchParams.append(`${column}`, `gte.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value on the stated `column` is less than the\n   * specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  lt(column: keyof T, value: T[keyof T]): this {\n    this.url.searchParams.append(`${column}`, `lt.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value on the stated `column` is less than or equal\n   * to the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  lte(column: keyof T, value: T[keyof T]): this {\n    this.url.searchParams.append(`${column}`, `lte.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value in the stated `column` matches the supplied\n   * `pattern` (case sensitive).\n   *\n   * @param column  The column to filter on.\n   * @param pattern  The pattern to filter with.\n   */\n  like(column: keyof T, pattern: string): this {\n    this.url.searchParams.append(`${column}`, `like.${pattern}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value in the stated `column` matches the supplied\n   * `pattern` (case insensitive).\n   *\n   * @param column  The column to filter on.\n   * @param pattern  The pattern to filter with.\n   */\n  ilike(column: keyof T, pattern: string): this {\n    this.url.searchParams.append(`${column}`, `ilike.${pattern}`)\n    return this\n  }\n\n  /**\n   * A check for exact equality (null, true, false), finds all rows whose\n   * value on the stated `column` exactly match the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  is(column: keyof T, value: boolean | null): this {\n    this.url.searchParams.append(`${column}`, `is.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value on the stated `column` is found on the\n   * specified `values`.\n   *\n   * @param column  The column to filter on.\n   * @param values  The values to filter with.\n   */\n  in(column: keyof T, values: T[keyof T][]): this {\n    const cleanedValues = values\n      .map((s) => {\n        // handle postgrest reserved characters\n        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n        if (typeof s === 'string' && new RegExp('[,()]').test(s)) return `\"${s}\"`\n        else return `${s}`\n      })\n      .join(',')\n    this.url.searchParams.append(`${column}`, `in.(${cleanedValues})`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose json, array, or range value on the stated `column`\n   * contains the values specified in `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  contains(column: keyof T, value: string | T[keyof T][] | object): this {\n    if (typeof value === 'string') {\n      // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n      // keep it simple and accept a string\n      this.url.searchParams.append(`${column}`, `cs.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(`${column}`, `cs.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(`${column}`, `cs.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  /** @deprecated Use `contains()` instead. */\n  cs = this.contains\n\n  /**\n   * Finds all rows whose json, array, or range value on the stated `column` is\n   * contained by the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  containedBy(column: keyof T, value: string | T[keyof T][] | object): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(`${column}`, `cd.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(`${column}`, `cd.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(`${column}`, `cd.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  /** @deprecated Use `containedBy()` instead. */\n  cd = this.containedBy\n\n  /**\n   * Finds all rows whose range value on the stated `column` is strictly to the\n   * left of the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeLt(column: keyof T, range: string): this {\n    this.url.searchParams.append(`${column}`, `sl.${range}`)\n    return this\n  }\n\n  /** @deprecated Use `rangeLt()` instead. */\n  sl = this.rangeLt\n\n  /**\n   * Finds all rows whose range value on the stated `column` is strictly to\n   * the right of the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeGt(column: keyof T, range: string): this {\n    this.url.searchParams.append(`${column}`, `sr.${range}`)\n    return this\n  }\n\n  /** @deprecated Use `rangeGt()` instead. */\n  sr = this.rangeGt\n\n  /**\n   * Finds all rows whose range value on the stated `column` does not extend\n   * to the left of the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeGte(column: keyof T, range: string): this {\n    this.url.searchParams.append(`${column}`, `nxl.${range}`)\n    return this\n  }\n\n  /** @deprecated Use `rangeGte()` instead. */\n  nxl = this.rangeGte\n\n  /**\n   * Finds all rows whose range value on the stated `column` does not extend\n   * to the right of the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeLte(column: keyof T, range: string): this {\n    this.url.searchParams.append(`${column}`, `nxr.${range}`)\n    return this\n  }\n\n  /** @deprecated Use `rangeLte()` instead. */\n  nxr = this.rangeLte\n\n  /**\n   * Finds all rows whose range value on the stated `column` is adjacent to\n   * the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeAdjacent(column: keyof T, range: string): this {\n    this.url.searchParams.append(`${column}`, `adj.${range}`)\n    return this\n  }\n\n  /** @deprecated Use `rangeAdjacent()` instead. */\n  adj = this.rangeAdjacent\n\n  /**\n   * Finds all rows whose array or range value on the stated `column` overlaps\n   * (has a value in common) with the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  overlaps(column: keyof T, value: string | T[keyof T][]): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(`${column}`, `ov.${value}`)\n    } else {\n      // array\n      this.url.searchParams.append(`${column}`, `ov.{${value.join(',')}}`)\n    }\n    return this\n  }\n\n  /** @deprecated Use `overlaps()` instead. */\n  ov = this.overlaps\n\n  /**\n   * Finds all rows whose text or tsvector value on the stated `column` matches\n   * the tsquery in `query`.\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   * @param type  The type of tsquery conversion to use on `query`.\n   */\n  textSearch(\n    column: keyof T,\n    query: string,\n    {\n      config,\n      type = null,\n    }: { config?: string; type?: 'plain' | 'phrase' | 'websearch' | null } = {}\n  ): this {\n    let typePart = ''\n    if (type === 'plain') {\n      typePart = 'pl'\n    } else if (type === 'phrase') {\n      typePart = 'ph'\n    } else if (type === 'websearch') {\n      typePart = 'w'\n    }\n    const configPart = config === undefined ? '' : `(${config})`\n    this.url.searchParams.append(`${column}`, `${typePart}fts${configPart}.${query}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose tsvector value on the stated `column` matches\n   * to_tsquery(`query`).\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   *\n   * @deprecated Use `textSearch()` instead.\n   */\n  fts(column: keyof T, query: string, { config }: { config?: string } = {}): this {\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`\n    this.url.searchParams.append(`${column}`, `fts${configPart}.${query}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose tsvector value on the stated `column` matches\n   * plainto_tsquery(`query`).\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   *\n   * @deprecated Use `textSearch()` with `type: 'plain'` instead.\n   */\n  plfts(column: keyof T, query: string, { config }: { config?: string } = {}): this {\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`\n    this.url.searchParams.append(`${column}`, `plfts${configPart}.${query}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose tsvector value on the stated `column` matches\n   * phraseto_tsquery(`query`).\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   *\n   * @deprecated Use `textSearch()` with `type: 'phrase'` instead.\n   */\n  phfts(column: keyof T, query: string, { config }: { config?: string } = {}): this {\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`\n    this.url.searchParams.append(`${column}`, `phfts${configPart}.${query}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose tsvector value on the stated `column` matches\n   * websearch_to_tsquery(`query`).\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   *\n   * @deprecated Use `textSearch()` with `type: 'websearch'` instead.\n   */\n  wfts(column: keyof T, query: string, { config }: { config?: string } = {}): this {\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`\n    this.url.searchParams.append(`${column}`, `wfts${configPart}.${query}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose `column` satisfies the filter.\n   *\n   * @param column  The column to filter on.\n   * @param operator  The operator to filter with.\n   * @param value  The value to filter with.\n   */\n  filter(column: keyof T, operator: FilterOperator, value: any): this {\n    this.url.searchParams.append(`${column}`, `${operator}.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose columns match the specified `query` object.\n   *\n   * @param query  The object to filter with, with column names as keys mapped\n   *               to their filter values.\n   */\n  match(query: Record<string, unknown>): this {\n    Object.keys(query).forEach((key) => {\n      this.url.searchParams.append(`${key}`, `eq.${query[key]}`)\n    })\n    return this\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}